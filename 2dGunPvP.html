<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Army Battle 2D - P v P</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* --- GIỮ NGUYÊN CSS CŨ --- */
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; font-family: 'Segoe UI', Tahoma, sans-serif; touch-action: none; }
        body { background-color: #1a1a1a; display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; overflow: hidden; }
        #game-container { position: relative; width: 100%; height: 100%; max-width: 900px; max-height: 500px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7); border-radius: 5px; overflow: hidden; background: #000; }
        @media (max-width: 900px) { #game-container { width: 100%; height: 65vh; max-height: none; border-radius: 0; position: absolute; top: 50%; transform: translateY(-50%); } }
        canvas { display: block; width: 100%; height: 100%; cursor: grab; }
        canvas:active { cursor: grabbing; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #ui-layer>* { pointer-events: auto; }
        
        #minimap-overlay { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); backdrop-filter: blur(3px); z-index: 19; transition: opacity 0.2s; }
        #minimap-container { position: absolute; top: 15px; right: 15px; width: 150px; background-color: rgba(0, 0, 0, 0.8); border: 2px solid #555; border-radius: 4px; z-index: 20; pointer-events: none; overflow: visible; transition: opacity 0.3s; }
        #minimapCanvas { width: 100%; height: 100%; display: block; border-radius: 2px; }
        #btn-close-map { display: none; position: absolute; top: -10px; right: -10px; width: 24px; height: 24px; background: #d32f2f; color: white; border: 2px solid #fff; border-radius: 50%; z-index: 21; cursor: pointer; justify-content: center; align-items: center; font-size: 12px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); }
        #btn-toggle-map { display: none; position: absolute; top: 60px; right: 15px; z-index: 18; background: rgba(0, 0, 0, 0.8); color: #ddd; border: 1px solid #666; border-radius: 6px; padding: 5px 10px; font-size: 10px; font-weight: bold; cursor: pointer; text-transform: uppercase; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); }
        #btn-toggle-map.active { background: #004d40; color: #fff; border-color: #009688; }
        
        #pause-menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(5px); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 101; color: white; }
        #pause-menu.hidden { display: none; }

        .hud-top-left { position: absolute; top: 15px; left: 15px; display: flex; flex-direction: column; gap: 8px; width: 220px; }
        .stats-row { display: flex; gap: 4px; }
        .stat-box { background-color: rgba(40, 50, 60, 0.85); color: white; padding: 5px 8px; border-radius: 4px; font-size: 11px; font-weight: bold; flex: 1; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); white-space: nowrap; }
        .bar-container { display: flex; flex-direction: column; gap: 5px; background-color: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 6px; }
        .bar-row { display: flex; align-items: center; gap: 8px; }
        .bar-label { color: #ddd; font-size: 10px; width: 50px; font-weight: bold; }
        .progress-track { flex-grow: 1; height: 6px; background: #444; border-radius: 3px; overflow: hidden; border: 1px solid #666; position: relative; }
        .progress-fill { height: 100%; border-radius: 3px; transition: width 0.1s; }
        .fill-move { background: linear-gradient(90deg, #00c853, #69f0ae); width: 100%; }
        .fill-power { background: linear-gradient(90deg, #ff6d00, #ffd180); width: 0%; }
        .chat-history-box { margin-top: 5px; background-color: rgba(20, 20, 20, 0.6); border-radius: 6px; padding: 8px; height: 95px; display: none; flex-direction: column; justify-content: flex-end; overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.1); pointer-events: none; }
        .chat-item { font-size: 11px; color: #eee; margin-bottom: 3px; line-height: 1.4; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8); animation: fadeIn 0.3s ease-out; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chat-name { font-weight: bold; color: #ff5722; margin-right: 5px; }
        .chat-system { color: #d500f9; font-weight: bold; font-style: italic; }
        .chat-finish { color: #d5e216; font-weight: bold; text-transform: uppercase; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        
        .turn-badge { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(20, 20, 20, 0.95); color: #ff9800; padding: 6px 20px; border-radius: 12px; border: 1px solid #555; font-weight: bold; font-size: 13px; text-transform: uppercase; box-shadow: 0 3px 10px rgba(0, 0, 0, 0.6); z-index: 10; display: flex; flex-direction: column; align-items: center; gap: 4px; white-space: nowrap; min-width: 140px; }
        
        .pause-text-btn { cursor: pointer; color: #ffeb3b; font-size: 10px; font-weight: bold; padding: 1px 5px; border-radius: 3px; background: rgba(255, 255, 255, 0.1); border: 1px solid #555; transition: all 0.2s; }
        .pause-text-btn:hover { background: rgba(255, 255, 255, 0.2); border-color: #ffeb3b; }
        .pause-text-btn:active { transform: scale(0.95); }

        .timer-warning { color: #ff3d00 !important; animation: pulse-red 0.5s infinite alternate; }
        @keyframes pulse-red { from { opacity: 1; } to { opacity: 0.5; } }
        .controls-area { position: absolute; bottom: 20px; left: 20px; transition: opacity 0.3s ease; }
        .d-pad { display: grid; grid-template-columns: 45px 45px 45px; grid-template-rows: 45px 45px 45px; gap: 5px; }
        .d-btn { width: 100%; height: 100%; background: rgba(60, 70, 80, 0.8); border: 1px solid #555; border-radius: 8px; color: white; display: flex; justify-content: center; align-items: center; cursor: pointer; font-size: 20px; -webkit-tap-highlight-color: transparent; }
        .d-btn:active { background: #888; transform: scale(0.95); }
        .btn-up { grid-column: 2; grid-row: 1; }
        .btn-left { grid-column: 1; grid-row: 2; }
        .btn-right { grid-column: 3; grid-row: 2; }
        .btn-down { grid-column: 2; grid-row: 3; }
        
        .action-container { position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; align-items: center; gap: 12px; transition: opacity 0.3s ease; }
        .skills-row { display: flex; gap: 10px; }
        .skill-btn { width: 45px; height: 45px; border-radius: 50%; background: #333; border: 2px solid #555; color: #777; display: flex; justify-content: center; align-items: center; font-size: 18px; cursor: not-allowed; position: relative; transition: all 0.2s; box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5); }
        .skill-btn.unlocked { background: #004d40; border-color: #009688; color: #fff; cursor: pointer; }
        .skill-btn.active { background: #00bfa5; border-color: #fff; box-shadow: 0 0 15px #00e676; transform: scale(1.1); }
        .skill-btn.used { background: #222 !important; border-color: #444 !important; color: #555 !important; cursor: not-allowed !important; opacity: 0.5; box-shadow: none !important; transform: none !important; }
        .skill-info { position: absolute; top: -35px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.9); color: #fff; font-size: 9px; padding: 3px 6px; border-radius: 4px; white-space: nowrap; opacity: 0; transition: opacity 0.2s; pointer-events: none; border: 1px solid #555; z-index: 100; text-align: center; }
        .skill-btn:active .skill-info, .skill-btn.active .skill-info { opacity: 1; }
        
        .btn-fire { width: 85px; height: 85px; border-radius: 50%; background: linear-gradient(135deg, #d32f2f, #b71c1c); border: 3px solid rgba(255, 255, 255, 0.8); color: white; font-weight: bold; font-size: 16px; cursor: pointer; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5); outline: none; -webkit-tap-highlight-color: transparent; transition: all 0.3s ease; display: flex; justify-content: center; align-items: center; }
        .btn-fire:active { transform: scale(0.9); background: #b71c1c; }
        .btn-fire.skill-active-mode { background: linear-gradient(135deg, #6200ea, #b388ff); box-shadow: 0 0 15px #d500f9, 0 0 30px #aa00ff, inset 0 0 10px rgba(255, 255, 255, 0.5); border: 2px solid #fff; animation: pulse-skill 0.8s infinite alternate; font-size: 18px; text-shadow: 0 0 5px #fff; }
        @keyframes pulse-skill { from { transform: scale(1); box-shadow: 0 0 15px #d500f9; } to { transform: scale(1.05); box-shadow: 0 0 30px #d500f9, 0 0 10px #fff; } }
        
        #start-menu, #end-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.92); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; color: white; }
        #end-screen.hidden, #start-menu.hidden { display: none; }
        .menu-title { font-size: 28px; margin-bottom: 30px; color: #fff; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px #fff; text-align: center; }
        .diff-btn { width: 220px; padding: 15px; margin: 10px 0; border: none; border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; transition: transform 0.2s, filter 0.2s; color: white; text-transform: uppercase; box-shadow: 0 4px 0 rgba(0, 0, 0, 0.5); position: relative; }
        .diff-btn:active { transform: translateY(4px); box-shadow: none; }
        .diff-btn.easy { background: linear-gradient(to right, #4CAF50, #8BC34A); }
        .diff-btn.hard { background: linear-gradient(to right, #FF9800, #FF5722); }
        .diff-btn.impossible { background: linear-gradient(to right, #6200EA, #D500F9); border: 2px solid #fff; box-shadow: 0 0 15px #D500F9; }
        .diff-info { font-size: 11px; font-weight: normal; display: block; margin-top: 3px; opacity: 0.9; text-transform: none; }
        #end-msg { font-size: 40px; margin-bottom: 20px; text-transform: uppercase; }
        button.restart-btn { padding: 10px 25px; font-size: 18px; border-radius: 25px; background: linear-gradient(45deg, #ff4b1f, #ff9068); color: white; border: none; cursor: pointer; }
        
        /* --- STYLE CHO MENU CHỌN XE --- */
        .nav-btn { background: rgba(255,255,255,0.1); border: 1px solid #777; color: white; border-radius: 5px; cursor: pointer; transition: all 0.2s; }
        .nav-btn:hover { background: rgba(255,255,255,0.2); border-color: #fff; }
        .nav-btn:active { transform: scale(0.95); }

        /* --- THÊM STYLE CHO VẠCH LỰC CŨ --- */
        #last-power-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px; /* Độ dày vạch */
            background-color: #fff; /* Màu trắng nổi bật */
            box-shadow: 0 0 4px #000; /* Bóng đen để dễ nhìn trên nền sáng */
            z-index: 5;
            display: none; /* Mặc định ẩn */
            pointer-events: none;
        }
        /* [FIX] Xếp các nút độ khó theo chiều dọc */
        #difficulty-buttons {
            display: flex;
            flex-direction: column; /* Xếp dọc */
            align-items: center;    /* Căn giữa */
            gap: 15px;              /* Khoảng cách giữa các nút */
            width: 100%;
        }
        
        /* Chỉnh lại nút cho đẹp khi xếp dọc */
        .diff-btn {
            width: 80%;           /* Chiều rộng nút */
            max-width: 300px;     /* Không quá to trên PC */
            margin: 0;            /* Bỏ margin cũ */
        }

        @media (max-width: 600px) { 
            .menu-title { font-size: 22px; } .diff-btn { width: 80%; font-size: 16px; } 
            .hud-top-left { width: 175px; gap: 4px; } .stat-box { padding: 4px 4px; font-size: 9px; } .bar-label { width: 40px; font-size: 9px; } 
            .chat-history-box { height: auto; min-height: 20px; padding: 5px; margin-top: 3px; background-color: rgba(20, 20, 20, 0.6); justify-content: flex-end; } .chat-history-box .chat-item:not(:nth-last-child(-n+2)) { display: none; } .chat-item { font-size: 11px; margin-bottom: 3px; line-height: 1.3; } 
            .turn-badge { left: auto; right: 15px; top: 15px; transform: none; font-size: 10px; padding: 5px 15px; } 
            #minimap-overlay.show { display: block; } 
            #minimap-container { display: none; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 20px rgba(0, 0, 0, 0.8); border: 2px solid #fff; pointer-events: auto; } #minimap-container.show { display: block; } 
            #btn-close-map { display: flex; } 
            #btn-toggle-map { display: block; top: 75px; right: 15px; } 
            .controls-area { bottom: 15px; left: 10px; } .d-pad { grid-template-columns: 32px 32px 32px; grid-template-rows: 32px 32px 32px; gap: 2px; } .d-btn { font-size: 14px; border-radius: 5px; } 
            .action-container { bottom: 15px; right: 10px; gap: 8px; } .skills-row { gap: 6px; } .skill-btn { width: 35px; height: 35px; font-size: 14px; } .btn-fire { width: 55px; height: 55px; font-size: 12px; border-width: 2px; } .btn-fire.skill-active-mode { font-size: 12px; } 
        }
    </style>
</head>

<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="start-menu">
            <div id="step-p1" style="display: flex; flex-direction: column; align-items: center; width: 100%; animation: fadeIn 0.5s;">
                <h1 class="menu-title" style="color: #00d2ff; text-shadow: 0 0 10px #00d2ff;">PLAYER 1</h1>
                <h2 style="color:#aaa; font-size:14px; margin-bottom:15px; letter-spacing: 1px;">CHỌN CHIẾN XA</h2>
                
                <div style="display:flex; align-items:center; justify-content:center; gap:15px;">
                    <button class="nav-btn" onclick="changeTankP1(-1)" style="padding:10px 15px;">&lt;</button>
                    <div style="width:220px; height:80px; background:rgba(0,0,0,0.6); border:1px solid #00d2ff; border-radius:5px; display:flex; flex-direction:column; align-items:center; justify-content:center; padding: 5px;">
                        <div id="p1-tank-name" style="color:#00d2ff; font-weight:bold; font-size:16px;">TANK NAME</div>
                        <div id="p1-tank-desc" style="color:#aaa; font-size:10px; font-style: italic; text-align:center;">Description</div>
                    </div>
                    <button class="nav-btn" onclick="changeTankP1(1)" style="padding:10px 15px;">&gt;</button>
                </div>

                <button class="restart-btn" style="margin-top: 30px; margin-bottom: 10px; background: linear-gradient(45deg, #00d2ff, #0091ea);" onclick="goToStep('p2')">TIẾP THEO</button>
                <a href="guide.html" style="
                margin-top: 15px;
                color: #aaa;
                text-decoration: none;
                font-size: 12px;
                border: 1px solid #555;
                padding: 5px 15px;
                border-radius: 15px;
                background: rgba(0,0,0,0.5);
                transition: all 0.2s;
            " onmouseover="this.style.borderColor='#fff'; this.style.color='#fff'" 
            onmouseout="this.style.borderColor='#555'; this.style.color='#aaa'">
            <i class="fas fa-book"></i> XEM HƯỚNG DẪN & CHỈ SỐ
            </a>
                <a href="index.html" style="
                margin-top: 15px;
                color: #aaa;
                text-decoration: none;
                font-size: 12px;
                border: 1px solid #555;
                padding: 5px 15px;
                border-radius: 15px;
                background: rgba(0,0,0,0.5);
                transition: all 0.2s;
            " onmouseover="this.style.borderColor='#fff'; this.style.color='#fff'" 
            onmouseout="this.style.borderColor='#555'; this.style.color='#aaa'">
            CHƠI CHẾ ĐỘ NGƯỜI VS MÁY
            </a>
            </div>

            <div id="step-p2" style="display: none; flex-direction: column; align-items: center; width: 100%; animation: fadeIn 0.5s;">
                <h1 class="menu-title" style="color: #ff3d00; text-shadow: 0 0 10px #ff3d00;">PLAYER 2</h1>
                <h2 style="color:#aaa; font-size:14px; margin-bottom:15px; letter-spacing: 1px;">CHỌN CHIẾN XA</h2>

                <div style="display:flex; align-items:center; justify-content:center; gap:15px;">
                    <button class="nav-btn" onclick="changeTankP2(-1)" style="padding:10px 15px;">&lt;</button>
                    <div style="width:220px; height:80px; background:rgba(0,0,0,0.6); border:1px solid #ff3d00; border-radius:5px; display:flex; flex-direction:column; align-items:center; justify-content:center; padding: 5px;">
                        <div id="p2-tank-name" style="color:#ff3d00; font-weight:bold; font-size:16px;">TANK NAME</div>
                        <div id="p2-tank-desc" style="color:#aaa; font-size:10px; font-style: italic; text-align:center;">Description</div>
                    </div>
                    <button class="nav-btn" onclick="changeTankP2(1)" style="padding:10px 15px;">&gt;</button>
                </div>

                <div style="display: flex; gap: 20px; margin-top: 30px;">
                    <button class="restart-btn" style="background: #555; font-size: 16px; padding: 8px 20px;" onclick="goToStep('p1')">QUAY LẠI</button>
                    <button class="restart-btn" style="background: linear-gradient(45deg, #ff3d00, #dd2c00);" onclick="goToStep('map')">TIẾP THEO</button>
                </div>
            </div>
            
            <div id="step-map" style="display:none; width: 100%; flex-direction:column; align-items:center; animation: fadeIn 0.5s;">
                <h1 class="menu-title" style="font-size: 24px; margin-bottom: 20px;">CHỌN BẢN ĐỒ</h1>

                <div style="display:flex; align-items:center; justify-content:center; gap:15px; margin-bottom: 15px;">
                    <button class="nav-btn" onclick="changeMap(-1)" style="padding:10px 15px;">&lt;</button>
                    <div style="width:220px; height:60px; background:rgba(0,0,0,0.6); border:1px solid #00e676; border-radius:5px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
                        <div id="map-preview-name" style="color:#00e676; font-weight:bold; font-size:16px;">MAP NAME</div>
                        <div id="map-preview-desc" style="color:#aaa; font-size:10px; font-style: italic;">Description</div>
                    </div>
                    <button class="nav-btn" onclick="changeMap(1)" style="padding:10px 15px;">&gt;</button>
                </div>

                <div style="display: flex; gap: 20px; margin-top: 25px;">
                    <button class="restart-btn" style="background: #555; font-size: 16px; padding: 8px 20px;" onclick="goToStep('p2')">QUAY LẠI</button>
                    <button class="restart-btn" style="box-shadow: 0 0 15px rgba(0, 230, 118, 0.5); background: linear-gradient(45deg, #00e676, #00c853);" onclick="confirmStartGame()">CHIẾN!</button>
                </div>
            </div>
        </div>

        <div id="end-screen" class="hidden">
            <h1 id="end-msg">YOU WIN</h1>
            <button class="restart-btn" onclick="location.reload()">Chơi lại</button>
        </div>

        <div id="ui-layer">
            
            <div id="pause-menu" class="hidden">
                <h1 class="menu-title">TẠM DỪNG</h1>
                <button class="restart-btn" onclick="togglePause()">Tiếp Tục</button>
                <button class="restart-btn" style="margin-top: 15px; background: #555;" onclick="location.reload()">Thoát Game</button>
            </div>

            <div id="minimap-overlay"></div>

            <div id="minimap-container">
                <div id="btn-close-map"><i class="fas fa-times"></i></div>
                <canvas id="minimapCanvas"></canvas>
            </div>

            <div id="btn-toggle-map">XEM MAP</div>

            <div class="turn-badge" id="turn-badge">
                <div style="border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 4px; margin-bottom: 4px; width: 100%; display: flex; justify-content: space-between; align-items: center;">
                    <span id="mode-text" style="color:#aaa; letter-spacing: 1px; font-size: 10px;">DỄ</span>
                    <span id="btn-pause-text" class="pause-text-btn">DỪNG</span>
                </div>
                <div style="display: flex; gap: 10px; font-size: 10px; align-items: center;">
                    <span>Lượt: <span id="turn-text" style="color: #00d2ff">BẠN</span></span>
                    <span style="color: #555">|</span>
                    <span id="timer-text" style="color:#fff; min-width: 25px; text-align:center;">20s</span>
                </div>
            </div>

            <div class="hud-top-left">
                <div class="stats-row">
                    <div class="stat-box">Gió: <span id="wind-val" class="text-blue" style="margin-left:4px; color:#00d2ff">0</span></div>
                    <div class="stat-box">Góc: <span id="angle-val" class="text-yellow" style="margin-left:4px; color:#ffd700">0°</span></div>
                    <div class="stat-box">HP: <span id="hp-val" class="text-red" style="margin-left:4px; color:#ff5252">100</span></div>
                </div>
                <div class="bar-container">
                    <div class="bar-row">
                        <span class="bar-label">Mana</span>
                        <div class="progress-track">
                            <div class="progress-fill fill-move" id="move-bar"></div>
                        </div>
                    </div>
                    <div class="bar-row">
                        <span class="bar-label">Lực</span>
                        <div class="progress-track">
                            <div class="progress-fill fill-power" id="power-bar"></div>
                            <div id="last-power-marker"></div> 
                        </div>
                    </div>
                </div>

                <div class="chat-history-box" id="chat-history"></div>
            </div>

            <div class="controls-area">
                <div class="d-pad">
                    <div class="d-btn btn-up" id="btn-up"><i class="fas fa-caret-up"></i></div>
                    <div class="d-btn btn-left" id="btn-left"><i class="fas fa-caret-left"></i></div>
                    <div class="d-btn btn-right" id="btn-right"><i class="fas fa-caret-right"></i></div>
                    <div class="d-btn btn-down" id="btn-down"><i class="fas fa-caret-down"></i></div>
                </div>
            </div>

            <div class="action-container">
                <div class="skills-row">
                    <div class="skill-btn" id="btn-skill-1">
                        <i class="fas fa-meteor"></i>
                        <div class="skill-info">Skill 1</div>
                    </div>
                    <div class="skill-btn" id="btn-skill-2">
                        <i class="fas fa-crosshairs"></i>
                        <div class="skill-info">Skill 2</div>
                    </div>
                    <div class="skill-btn" id="btn-skill-3">
                        <i class="fas fa-shield-alt"></i>
                        <div class="skill-info">Khiên (< 40% HP)</div>
                    </div>
                    <div class="skill-btn" id="btn-skill-4">
                        <i class="fas fa-parachute-box"></i>
                        <div class="skill-info">Tiếp Tế (< 50% HP)</div>
                    </div>
                </div>
                <button class="btn-fire" id="btn-fire">BẮN</button>
            </div>
        </div>
    </div>
    <script>
        // --- CONSTANTS & SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container');

        let VIEWPORT_W = container.clientWidth;
        let SCREEN_H = container.clientHeight;
        let GAME_SCALE = 1;

        // ==========================================
        // === 1. MAP SYSTEM (NEW OOP) ===
        // ==========================================
        
        // Định nghĩa Class Map trước để khởi tạo Constants
        class BaseMap {
            constructor(config) {
                this.width = config.width || 1200;
                this.height = config.height || 1000;
                this.groundY = config.groundY || (this.height - 220);
                this.gravity = config.gravity || 0.15;
                this.windMulti = config.windMulti || 1.0;
                this.themeColor = config.themeColor || '#87CEEB';
                this.minX = config.minX || 25;
                this.maxX = config.maxX || (this.width - 25);
            }

            drawBackground(ctx, viewportW, screenH) {}
            drawForeground(ctx, cameraX, viewportW) {}
            isGroundCollision(x, y) { return y >= this.groundY; }

            getHeightAt(x) {
                return this.groundY;
            }

            // [NEW] Hàm xử lý phá hủy đất (Mặc định không làm gì)
            destroyGround(x, y, radius) {}

            // [NEW] Hàm vẽ Mini Map mặc định (Vẽ trời và đất cơ bản)
            drawMinimap(ctx, scale) {
                // 1. Vẽ nền trời
                ctx.fillStyle = this.themeColor;
                ctx.fillRect(0, 0, this.width * scale, this.height * scale);

                // 2. Vẽ đất
                ctx.fillStyle = '#666'; // Màu đất mặc định
                ctx.fillRect(0, this.groundY * scale, this.width * scale, (this.height - this.groundY) * scale);
            }
        }

        class IronBridgeCloud {
            constructor(mapW, mapH) {
                this.mapW = mapW;
                this.mapH = mapH;
                this.x = Math.random() * mapW;
                this.y = Math.random() * (mapH - 400); // Chỉ bay ở phần trên
                this.speed = (Math.random() * 0.2) + 0.1;
                this.size = (Math.random() * 0.5) + 0.5;
                this.parallaxX = 0.5; // Trôi chậm hơn camera một chút
                this.parallaxY = 0.2;
                
                // Tạo hình dáng mây (các cục bông)
                this.puffs = [];
                for (let i = 0; i < 5 + Math.random() * 5; i++) {
                    this.puffs.push({
                        x: (Math.random() - 0.5) * 60,
                        y: (Math.random() - 0.5) * 30,
                        r: 20 + Math.random() * 20
                    });
                }
            }

            update(windVal) {
                // Mây trôi theo gió
                this.x += this.speed + (windVal * 0.05);
                
                // Lặp lại vô tận
                if (this.x > this.mapW + 100) this.x = -100;
                else if (this.x < -100) this.x = this.mapW + 100;
            }

            draw(ctx, camX, camY, viewW, viewH) {
                // Tính toán vị trí vẽ (có parallax)
                let rx = this.x - (camX * this.parallaxX);
                let ry = this.y - (camY * this.parallaxY);

                // Chỉ vẽ khi nằm trong màn hình (Culling)
                if (rx > -150 && rx < viewW + 150 && ry > -100 && ry < viewH + 100) {
                    ctx.save();
                    ctx.translate(rx, ry);
                    ctx.scale(this.size, this.size);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    this.puffs.forEach(p => {
                        ctx.moveTo(p.x, p.y);
                        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    });
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        // --- MAP CẦU SẮT (Đã tích hợp mây) ---
       // --- MAP CẦU SẮT (Đã chỉnh sửa: Cầu lơ lửng, rơi xuống nước là chết) ---
        class IronBridgeMap extends BaseMap {
            constructor() {
                super({
                    width: 1500,
                    height: 1000,
                    groundY: 780,
                    gravity: 0.15,
                    themeColor: '#87CEEB',
                    // [QUAN TRỌNG] Cho phép đi ra sát mép màn hình (0-1500) để có thể rơi xuống nước
                    minX: 0, maxX: 1500 
                });

                // Cấu hình Cầu: Map 1500, Cầu 1200 -> Dư 300. Mỗi bên hở 150px.
                this.bridgeStart = 150; 
                this.bridgeEnd = 1350; 
                
                this.waterOffset = 0;
                
                // [FIX] ĐỒNG BỘ SPAWN VỚI ĐẢO DỪA (dist=700px)
                this.pSpawnX = 400;   // Thay 300 → 400 (dư 250px đầu cầu)
                this.aiSpawnX = 1100; // Thay 1200 → 1100 (dư 250px cuối cầu)

                // Mây
                this.clouds = [];
                for (let i = 0; i < 15; i++) {
                    this.clouds.push(new IronBridgeCloud(this.width, this.height));
                }
            }

            // [LOGIC MỚI] Lấy độ cao đất
            getHeightAt(x) {
                // Nếu vị trí x nằm NGOÀI phạm vi cầu -> Trả về Vực Thẳm (đáy map)
                if (x < this.bridgeStart || x > this.bridgeEnd) {
                    return this.height + 500; // Rất sâu để xe rơi tự do
                }
                // Nếu nằm TRÊN cầu -> Trả về mặt cầu
                return this.groundY;
            }

            // [LOGIC MỚI] Check va chạm
            isGroundCollision(x, y) {
                // Nếu nằm ngoài cầu -> Không bao giờ va chạm (Rơi xuyên qua)
                if (x < this.bridgeStart || x > this.bridgeEnd) return false;
                
                // Trên cầu thì check như thường
                return y >= this.groundY;
            }

            drawBackground(ctx, viewportW, screenH) {
                let grad = ctx.createLinearGradient(0, 0, 0, screenH);
                grad.addColorStop(0, '#87CEEB'); grad.addColorStop(0.6, '#B0E0E6'); grad.addColorStop(1, '#E0F7FA'); 
                ctx.fillStyle = grad; ctx.fillRect(0, 0, viewportW, screenH); 
                this.clouds.forEach(c => { c.update(wind); c.draw(ctx, cameraX, cameraY, viewportW, screenH); });
            }

            drawForeground(ctx, cameraX, viewportW) {
                this.waterOffset += 0.05;
                const bridgeH = 25; 
                
                // Vẽ chân cầu (Chỉ vẽ trong phạm vi cầu)
                ctx.fillStyle = '#444';
                for (let bx = this.bridgeStart + 100; bx < this.bridgeEnd; bx += 200) { 
                    if (bx - cameraX > -50 && bx - cameraX < viewportW + 50) 
                        ctx.fillRect(bx - 10, this.groundY + bridgeH, 20, this.height - this.groundY); 
                }

                // Vẽ mặt cầu (Giới hạn từ bridgeStart đến bridgeEnd)
                ctx.fillStyle = '#3a3a3a'; 
                ctx.fillRect(this.bridgeStart, this.groundY, this.bridgeEnd - this.bridgeStart, bridgeH);
                
                ctx.strokeStyle = '#222'; ctx.lineWidth = 4; ctx.beginPath(); 
                ctx.moveTo(this.bridgeStart, this.groundY); ctx.lineTo(this.bridgeEnd, this.groundY); 
                ctx.moveTo(this.bridgeStart, this.groundY + bridgeH); ctx.lineTo(this.bridgeEnd, this.groundY + bridgeH);
                
                // Vẽ thanh chéo
                for (let i = this.bridgeStart; i < this.bridgeEnd; i += 30) { 
                    if (i - cameraX > -50 && i - cameraX < viewportW + 50) { 
                        ctx.moveTo(i, this.groundY); ctx.lineTo(i + 15, this.groundY + bridgeH); ctx.lineTo(i + 30, this.groundY); 
                    } 
                } 
                ctx.stroke();

                // Vẽ lan can
                ctx.fillStyle = '#DDD'; ctx.fillRect(this.bridgeStart, this.groundY - 5, this.bridgeEnd - this.bridgeStart, 4); 
                ctx.fillStyle = '#999'; 
                for (let r = this.bridgeStart; r <= this.bridgeEnd; r += 20) { 
                    if (r - cameraX > -10 && r - cameraX < viewportW + 10) ctx.fillRect(r, this.groundY - 5, 2, 4); 
                }

                // Vẽ nước biển (Trải dài toàn map bên dưới)
                let wStart = Math.floor(cameraX / 10) * 10 - 20; if (wStart < 0) wStart = 0; 
                let wEnd = wStart + viewportW + 40; if (wEnd > this.width) wEnd = this.width;
                
                ctx.globalAlpha = 0.6; ctx.fillStyle = '#0288D1'; ctx.beginPath(); 
                ctx.moveTo(wStart, this.height); 
                for (let i = wStart; i <= wEnd; i += 10) ctx.lineTo(i, (this.groundY + 50) + Math.sin(i * 0.01 + this.waterOffset) * 10); 
                ctx.lineTo(wEnd, this.height); ctx.fill();
                
                ctx.globalAlpha = 0.5; ctx.fillStyle = '#4FC3F7'; ctx.beginPath(); 
                ctx.moveTo(wStart, this.height); 
                for (let i = wStart; i <= wEnd; i += 10) ctx.lineTo(i, (this.groundY + 60) + Math.sin(i * 0.015 + this.waterOffset + 1) * 8); 
                ctx.lineTo(wEnd, this.height); ctx.fill(); ctx.globalAlpha = 1.0;
            }

            drawMinimap(ctx, scale) {
                ctx.fillStyle = 'rgba(135, 206, 235, 0.2)'; 
                ctx.fillRect(0, 0, this.width * scale, this.height * scale);
                
                // Vẽ cầu trên minimap (ngắn lại)
                ctx.fillStyle = '#555'; 
                ctx.fillRect(this.bridgeStart * scale, this.groundY * scale, (this.bridgeEnd - this.bridgeStart) * scale, 6);
                
                // Vẽ nước
                ctx.fillStyle = 'rgba(2, 136, 209, 0.5)'; 
                ctx.fillRect(0, (this.groundY + 50) * scale, this.width * scale, (this.height - this.groundY) * scale);
            }
        }

        // --- 2. CẬP NHẬT COCONUT ISLAND MAP (FULL DESTRUCTIBLE) ---
        class CoconutIslandMap extends BaseMap {
            constructor() {
                super({
                    width: 1500,
                    height: 1000,
                    groundY: 800,
                    gravity: 0.15,
                    themeColor: '#4FC3F7',
                    minX: 50, maxX: 1450
                });
                
                // --- LOGIC VỊ TRÍ ---
                this.pSpawnX = 400;   
                this.aiSpawnX = 1100; 
                let distance = this.aiSpawnX - this.pSpawnX; 
                let segment = distance / 3; 
                this.tree1X = this.pSpawnX + segment;       
                this.tree2X = this.pSpawnX + (segment * 2); 

                // --- KHỞI TẠO HEIGHTMAP (ĐỊA HÌNH LÒNG CHẢO UỐN LƯỢN) ---
                this.heightMap = new Float32Array(this.width + 1);
                this.grassOffsets = new Float32Array(this.width + 1);

                // Tâm bản đồ
                let centerX = this.width / 2;

                for (let x = 0; x <= this.width; x++) {
                    // A. TẠO DÁNG "LÒNG CHẢO" (Cao 2 đầu, thấp ở giữa)
                    // Tính khoảng cách từ x tới tâm (chuẩn hóa từ -1 đến 1)
                    let distNorm = (x - centerX) / (this.width / 2); 
                    // Dùng hàm Parabol (x^2) để nâng cao 2 đầu lên khoảng 180px
                    let bowlOffset = Math.pow(distNorm, 2) * 180;

                    // B. TẠO ĐỘ UỐN LƯỢN (SÓNG ĐỒI)
                    // Sóng 1: Đồi lớn thoai thoải (Chu kỳ dài)
                    let hillWave = Math.sin(x * 0.006) * 40; 
                    // Sóng 2: Gập ghềnh nhỏ (Chu kỳ ngắn hơn)
                    let bumpWave = Math.sin(x * 0.02) * 10;

                    // C. TỔNG HỢP ĐỘ CAO
                    // groundY gốc (800) - Nâng 2 đầu - Đồi + Gập ghềnh
                    // (Lưu ý: Trong Canvas Y càng nhỏ càng cao nên ta dùng dấu trừ để nâng đất lên)
                    this.heightMap[x] = this.groundY - bowlOffset + hillWave + bumpWave; 

                    // D. VISUAL CỎ (Giữ nguyên độ xù xì hình ảnh)
                    this.grassOffsets[x] = (Math.random() - 0.5) * 6;
                }

                // --- ASSETS CŨ (GIỮ NGUYÊN) ---
                this.localClouds = [];
                for(let i=0; i<10; i++) {
                    this.localClouds.push({
                        x: Math.random() * this.width,
                        y: 50 + Math.random() * 300, 
                        size: 0.3 + Math.random() * 0.3, 
                        speed: Math.random() > 0.5 ? 0 : (0.05 + Math.random() * 0.1),
                        puffCount: 3 + Math.floor(Math.random() * 2)
                    });
                }

                this.mountainClusters = [];
                let clusterDist = 450; 
                for (let i = -1000; i < this.width + 2500; i += clusterDist) {
                    let clusterX = i + (Math.random() - 0.5) * 150; 
                    let peaks = [];
                    peaks.push({ xOff: (Math.random() - 0.5) * 100, w: 120 + Math.random() * 60, h: 40 + Math.random() * 20, color: '#CFD8DC' });
                    peaks.push({ xOff: -80 + (Math.random() * 60), w: 90 + Math.random() * 40, h: 50 + Math.random() * 25, color: '#B0BEC5' });
                    peaks.push({ xOff: 20 + (Math.random() * 80), w: 80 + Math.random() * 50, h: 70 + Math.random() * 25, color: '#90A4AE' });
                    this.mountainClusters.push({ x: clusterX, peaks: peaks });
                }

                this.islands = [];
                let islandX = [-100, 400, 950, 1600, 2200];
                islandX.forEach(x => {
                    this.islands.push({ x: x, yOffset: (Math.random() * 15), width: 50 + Math.random() * 40 });
                });
            }
            // [NEW] Hàm lấy độ cao đất tại vị trí X bất kỳ (Dùng cho xe tăng bám đất)
            getHeightAt(x) {
                let ix = Math.floor(x);
                // Giới hạn trong map để không lỗi
                if (ix < 0) ix = 0;
                if (ix > this.width) ix = this.width;
                return this.heightMap[ix];
            }

            // [LOGIC] Phá hủy đất với GIỚI HẠN ĐỘ SÂU (Chỉ logic, không vẽ đá)
            destroyGround(impactX, impactY, radius) {
                let startX = Math.floor(impactX - radius);
                let endX = Math.ceil(impactX + radius);
                startX = Math.max(0, startX);
                endX = Math.min(this.width, endX);

                let depthFactor = 0.6; // Hố dẹt

                // [QUAN TRỌNG] Giới hạn độ sâu: GroundY(800) + 150 = 950
                // Map cao 1000, vậy còn 50px ở đáy không bao giờ thủng
                let maxDepthLimit = this.groundY + 150; 

                for (let x = startX; x <= endX; x++) {
                    let dx = x - impactX;
                    let distSq = radius * radius - dx * dx;
                    
                    if (distSq > 0) {
                        let dy = Math.sqrt(distSq) * depthFactor;
                        let circleBottomY = impactY + dy;

                        // Nếu sâu hơn giới hạn -> Gán bằng giới hạn
                        if (circleBottomY > maxDepthLimit) {
                            circleBottomY = maxDepthLimit;
                        }

                        // Cập nhật heightMap
                        if (circleBottomY > this.heightMap[x]) {
                            this.heightMap[x] = circleBottomY;
                        }
                    }
                }
            }

            // [MODIFIED] Check va chạm dựa trên heightMap chính xác từng pixel
            isGroundCollision(x, y) {
                let ix = Math.floor(x);
                if (ix < 0 || ix > this.width) return false;
                
                // Va chạm đất
                if (y >= this.heightMap[ix]) return true;

                // Va chạm cây (Logic cũ)
                const treeW = 25, treeH = 90;
                // Lấy độ cao đất tại vị trí gốc cây
                let tree1Y = this.heightMap[Math.floor(this.tree1X)];
                let tree2Y = this.heightMap[Math.floor(this.tree2X)];

                if ((x > this.tree1X - 12 && x < this.tree1X + 12 && y > tree1Y - treeH && y < tree1Y) || 
                    (x > this.tree2X - 12 && x < this.tree2X + 12 && y > tree2Y - treeH && y < tree2Y)) return true;
                
                return false;
            }

            drawBackground(ctx, viewportW, screenH) {
                // --- GIỮ NGUYÊN HOÀN TOÀN CODE VẼ BACKGROUND CŨ ---
                let relGroundY = this.groundY - cameraY; 
                let relHorizonY = relGroundY - 200;      
                let paraMount = cameraX * 0.15; 
                let paraSeaX = cameraX * 0.5;   

                let skyHorizonColor = '#B3E5FC';
                let skyGrad = ctx.createLinearGradient(0, 0, 0, screenH);
                skyGrad.addColorStop(0, '#4FC3F7'); 
                skyGrad.addColorStop(1, skyHorizonColor); 
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, viewportW, screenH);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; 
                this.localClouds.forEach(cloud => {
                    cloud.x += cloud.speed;
                    if (cloud.x > this.width + 200) cloud.x = -200;
                    let cloudDrawX = cloud.x - (cameraX * 0.1); 
                    if (cloudDrawX < -200) cloudDrawX += (this.width + 500);
                    if (cloudDrawX > viewportW + 200) cloudDrawX -= (this.width + 500);
                    let cy = cloud.y - (cameraY * 0.05); 
                    if (cloudDrawX > -300 && cloudDrawX < viewportW + 300) {
                        ctx.save(); ctx.translate(cloudDrawX, cy); ctx.scale(cloud.size, cloud.size);
                        ctx.beginPath(); ctx.moveTo(40, 0); ctx.arc(0, 0, 40, 0, Math.PI*2); ctx.moveTo(100, 10); ctx.arc(50, 10, 50, 0, Math.PI*2); ctx.moveTo(130, 0); ctx.arc(90, 0, 40, 0, Math.PI*2); if (cloud.puffCount > 3) { ctx.moveTo(80, -30); ctx.arc(40, -30, 40, 0, Math.PI*2); } ctx.fill(); ctx.restore();
                    }
                });
                ctx.save(); ctx.fillStyle = '#FDD835'; ctx.shadowBlur = 40; ctx.shadowColor = '#FDD835'; ctx.beginPath(); ctx.arc(viewportW - 100, 100, 45, 0, Math.PI*2); ctx.fill(); ctx.restore();

                this.mountainClusters.forEach(cluster => {
                    let drawX = cluster.x - paraMount;
                    let loopWidth = 4500; 
                    drawX = ((drawX % loopWidth) + loopWidth) % loopWidth - 800; 
                    if (drawX > -400 && drawX < viewportW + 400) {
                        ctx.save(); ctx.translate(drawX, relHorizonY);
                        cluster.peaks.forEach(peak => {
                            let mtnGrad = ctx.createLinearGradient(0, -peak.h, 0, 0); mtnGrad.addColorStop(0, '#FFFFFF'); mtnGrad.addColorStop(0.3, '#FFFFFF'); mtnGrad.addColorStop(1, peak.color); 
                            ctx.fillStyle = mtnGrad; ctx.beginPath(); ctx.moveTo(peak.xOff - peak.w, 0); let topX = peak.xOff; let topY = -peak.h; ctx.lineTo(topX - 5, topY + 2); ctx.quadraticCurveTo(topX, topY, topX + 5, topY + 2); ctx.lineTo(peak.xOff + peak.w, 0); ctx.fill();
                        }); ctx.restore();
                    }
                });

                let shoreBaseY = relGroundY - 50;
                let seaGrad = ctx.createLinearGradient(0, relHorizonY, 0, shoreBaseY);
                seaGrad.addColorStop(0, skyHorizonColor); seaGrad.addColorStop(0.2, '#81D4FA'); seaGrad.addColorStop(0.5, '#039BE5'); seaGrad.addColorStop(1, 'rgba(79, 195, 247, 0.8)'); 
                ctx.fillStyle = seaGrad; ctx.fillRect(0, relHorizonY, viewportW, shoreBaseY - relHorizonY + 50);

                ctx.save(); ctx.translate(-paraSeaX, 0); 
                this.islands.forEach(island => {
                    let drawX = (island.x) % (viewportW + 1500); if (drawX < -200) drawX += viewportW + 1500;
                    let drawY = relHorizonY + 20 + island.yOffset;
                    let rockGrad = ctx.createLinearGradient(drawX, drawY - 20, drawX, drawY + 10); rockGrad.addColorStop(0, '#8D6E63'); rockGrad.addColorStop(1, '#3E2723');
                    ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(drawX, drawY + 2, island.width/2 + 5, 5, 0, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = rockGrad; ctx.beginPath(); ctx.arc(drawX, drawY, island.width/2, Math.PI, 0); ctx.fill();
                }); ctx.restore();

                let hazeHeight = 100; let hazeY = relHorizonY - 70; 
                let hazeGrad = ctx.createLinearGradient(0, hazeY, 0, hazeY + hazeHeight); hazeGrad.addColorStop(0, 'rgba(179, 229, 252, 0)'); hazeGrad.addColorStop(0.7, skyHorizonColor); hazeGrad.addColorStop(1, 'rgba(179, 229, 252, 0)');   
                ctx.fillStyle = hazeGrad; ctx.fillRect(0, hazeY, viewportW, hazeHeight);

                const drawCurvyLayer = (baseY, color, curveIntensity, offset) => {
                    ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(0, baseY); ctx.quadraticCurveTo(viewportW * 0.25, baseY + curveIntensity + offset, viewportW * 0.5, baseY - curveIntensity + offset); ctx.quadraticCurveTo(viewportW * 0.75, baseY - (curveIntensity * 1.5) + offset, viewportW, baseY + curveIntensity + offset); ctx.lineTo(viewportW, screenH); ctx.lineTo(0, screenH); ctx.closePath(); ctx.fill();
                }
                drawCurvyLayer(shoreBaseY, '#8D6E63', 15, 10); 
                drawCurvyLayer(shoreBaseY + 15, '#A1887F', 15, 10);
                drawCurvyLayer(shoreBaseY + 35, '#FFE0B2', 15, 10);
                drawCurvyLayer(shoreBaseY - 5, 'rgba(255, 255, 255, 0.8)', 12, -2);
                drawCurvyLayer(shoreBaseY, 'rgba(255, 255, 255, 0.5)', 10, 0);
                drawCurvyLayer(shoreBaseY + 5, 'rgba(255, 255, 255, 0.8)', 8, 2);
            }

            drawForeground(ctx, cameraX, viewportW) {
            ctx.save();
            
            ctx.beginPath();
            let startIdx = Math.floor(Math.max(0, cameraX));
            let endIdx = Math.min(this.width, Math.ceil(cameraX + viewportW));
            let step = 1; 

            ctx.moveTo(startIdx, this.height);
            
            // [SỬA] Khi vẽ: Cộng thêm grassOffsets để tạo độ gồ ghề cho mắt nhìn
            for (let i = startIdx; i <= endIdx; i += step) {
                let idx = Math.floor(i);
                // Y vẽ = Độ cao thực tế (hố bom/đất phẳng) + Độ gồ ghề của cỏ
                let visualY = this.heightMap[idx] + this.grassOffsets[idx];
                ctx.lineTo(i, visualY);
        }
        
        ctx.lineTo(endIdx, this.height);
        ctx.lineTo(startIdx, this.height);
        ctx.closePath();
        
        ctx.save(); ctx.clip(); 
        
        // Tô màu nền đất
        let groundGrad = ctx.createLinearGradient(0, this.groundY, 0, this.height);
        groundGrad.addColorStop(0, '#FFCA28'); 
        groundGrad.addColorStop(1, '#E65100'); 
        ctx.fillStyle = groundGrad; 
        ctx.fill();

        // Vẽ vân đất (Trầm tích)
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)'; 
        ctx.lineWidth = 20;
        for(let d = 50; d < 400; d+= 60) {
            ctx.beginPath();
            let waveOffset = Math.sin(d) * 100;
            let startY = this.groundY + d + Math.sin(startIdx * 0.01 + waveOffset) * 20;
            ctx.moveTo(startIdx, startY);
            for (let x = startIdx; x <= endIdx; x += 10) {
                let waveY = Math.sin(x * 0.01 + waveOffset) * 20;
                ctx.lineTo(x, this.groundY + d + waveY);
            }
            ctx.stroke();
        }
        ctx.restore(); 

        // [SỬA] Vẽ viền cỏ đậm (Surface Grass) - Cũng phải cộng thêm grassOffsets
        ctx.strokeStyle = '#43A047'; 
        ctx.lineWidth = 6; 
        ctx.lineCap = 'round'; 
        ctx.beginPath();
        for (let i = startIdx; i <= endIdx; i += step) {
            let idx = Math.floor(i);
            let visualY = this.heightMap[idx] + this.grassOffsets[idx];
            if (i === startIdx) ctx.moveTo(i, visualY);
            else ctx.lineTo(i, visualY);
        }
        ctx.stroke();

        // [SỬA] Vẽ cỏ chi tiết (Từng cọng nhỏ) - Dựa trên visualY
        ctx.strokeStyle = '#66BB6A'; 
        ctx.lineWidth = 2;
        for (let i = startIdx; i <= endIdx; i+=3) {
            let idx = Math.floor(i);
            let h = this.heightMap[idx]; // Dùng độ cao thực tế để check xem có nên vẽ không
            let visualY = h + this.grassOffsets[idx]; // Dùng độ cao hiển thị để vẽ

            // Chỉ vẽ cỏ trang trí nếu đất không bị đào quá sâu
            if (Math.abs(h - this.groundY) < 15) { 
                ctx.beginPath(); 
                ctx.moveTo(i, visualY); 
                ctx.lineTo(i - 3, visualY - 6); 
                ctx.moveTo(i, visualY); 
                ctx.lineTo(i, visualY - 8); 
                ctx.moveTo(i, visualY); 
                ctx.lineTo(i + 3, visualY - 6); 
                ctx.stroke();
            }
        }
        ctx.restore();

        // Vẽ cây (Dùng heightMap gốc để gốc cây bám chặt vào đất vật lý)
        let tree1Y = this.heightMap[Math.floor(this.tree1X)];
        let tree2Y = this.heightMap[Math.floor(this.tree2X)];

        if (this.tree1X - cameraX > -100 && this.tree1X - cameraX < viewportW + 100) this.drawShortCoconutTree(ctx, this.tree1X, tree1Y);
        if (this.tree2X - cameraX > -100 && this.tree2X - cameraX < viewportW + 100) this.drawShortCoconutTree(ctx, this.tree2X, tree2Y);
    }

            drawShortCoconutTree(ctx, x, y) {
                // (GIỮ NGUYÊN HÀM CŨ CỦA BẠN - KHÔNG COPY LẠI ĐỂ TIẾT KIỆM DÒNG)
                // ... Dùng lại hàm drawShortCoconutTree từ file gốc ...
                ctx.save();
                        ctx.translate(x, y);

                        // ===============================================
                        // 1. VẼ THÂN CÂY
                        // ===============================================
                        const trunkW = 20;
                        const trunkH = 60;

                        ctx.save();
                        ctx.fillStyle = '#8D6E63';
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2.5;

                        ctx.beginPath();
                        ctx.moveTo(-trunkW / 2 - 5, 0);
                        ctx.quadraticCurveTo(-trunkW / 2, -trunkH / 2, -trunkW / 2 + 5, -trunkH);
                        ctx.lineTo(trunkW / 2 - 5, -trunkH);
                        ctx.quadraticCurveTo(trunkW / 2, -trunkH / 2, trunkW / 2 + 5, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        // Ngấn thân cây
                        ctx.beginPath();
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = '#3E2723';
                        ctx.moveTo(-11, -15); ctx.quadraticCurveTo(0, -12, 11, -15);
                        ctx.moveTo(-9, -30); ctx.quadraticCurveTo(0, -27, 9, -30);
                        ctx.moveTo(-7, -45); ctx.quadraticCurveTo(0, -42, 7, -45);
                        ctx.stroke();
                        ctx.restore();

                        // Dời gốc toạ độ lên đỉnh ngọn cây
                        ctx.translate(0, -trunkH);

                        // ===============================================
                        // 2. VẼ 4 CHIẾC LÁ
                        // ===============================================
                        
                        const drawOneLeaf = () => {
                            ctx.beginPath();
                            ctx.moveTo(-40, 10);
                            ctx.bezierCurveTo(-30, -30, 30, -30, 40, 10); // Vòm trên
                            ctx.lineTo(20, 10);
                            ctx.lineTo(10, 0);    // Răng cưa 1
                            ctx.lineTo(0, 10);
                            ctx.lineTo(-10, 0);   // Răng cưa 2
                            ctx.lineTo(-20, 10);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        };

                        ctx.fillStyle = '#008000';
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1.5;

                        // --- LÁ 3 & 4: CẶP TRÊN (HƯỚNG LÊN) ---
                        
                        // Lá 3 (Trên - Trái)
                        ctx.save();
                        ctx.translate(-23, -30);        
                        // Lưu ý: -Math.PI / -3.5 tương đương với Math.PI / 3.5 (số dương)
                        ctx.rotate(Math.PI / 3.5);     
                        drawOneLeaf();
                        ctx.restore();

                        // Lá 4 (Trên - Phải)
                        ctx.save();
                        ctx.translate(23, -30);          
                        ctx.scale(-1, 1);                
                        ctx.rotate(Math.PI / 3.1);  // Giữ sự bất đối xứng nhẹ cho tự nhiên   
                        drawOneLeaf();
                        ctx.restore();

                        // --- LÁ 1 & 2: CẶP DƯỚI (XÒE NGANG) ---
                        
                        // Lá 1 (Dưới - Trái)
                        ctx.save();
                        ctx.translate(-40, 1);
                        ctx.rotate(-Math.PI / 12);    
                        drawOneLeaf();
                        ctx.restore();

                        // Lá 2 (Dưới - Phải)
                        ctx.save();
                        ctx.translate(40, 1);
                        ctx.scale(-1, 1);
                        ctx.rotate(-Math.PI / 20); // Góc hơi khác lá 1 một chút
                        drawOneLeaf();
                        ctx.restore();

                        // ===============================================
                        // 3. VẼ QUẢ DỪA (LỚP TRÊN CÙNG)
                        // ===============================================
                        const drawCoconut = (cx, cy, radius) => {
                            ctx.beginPath();
                            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                            ctx.fillStyle = '#ADFF2F';
                            ctx.fill();
                            ctx.strokeStyle = '#000';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.arc(cx - 3, cy - 3, radius / 3, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                            ctx.fill();
                        };

                        drawCoconut(-12, 5, 11);
                        drawCoconut(12, 5, 11);
                        drawCoconut(0, 10, 12);

                        ctx.restore();
            }

            drawMinimap(ctx, scale) {
                ctx.fillStyle = 'rgba(135, 206, 235, 0.2)'; 
                ctx.fillRect(0, 0, this.width * scale, this.height * scale); 
                ctx.fillStyle = '#FFCA28'; 
                
                ctx.beginPath();
                ctx.moveTo(0, this.height * scale);
                // Vẽ lại hình dáng đất trên minimap
                for(let x=0; x<=this.width; x+=5) { 
                    ctx.lineTo(x * scale, this.heightMap[x] * scale);
                }
                ctx.lineTo(this.width * scale, this.height * scale);
                ctx.fill();
            }
        }

        // --- INIT MAP ---
        // let currentMap = new IronBridgeMap();
        // let currentMap = new CoconutIslandMap();
        let currentMap = new CoconutIslandMap(); // Mặc định để tránh lỗi null khi load trang

        // --- MAPPING GLOBAL VARS TO CURRENT MAP (BACKWARD COMPATIBILITY) ---
        // [FIX] Đổi thành let để có thể cập nhật khi đổi Map
        let MAP_WIDTH = currentMap.width;
        let MAP_HEIGHT = currentMap.height;
        let GROUND_Y = currentMap.groundY;
        let GRAVITY = currentMap.gravity;
        
        // Giữ nguyên các hằng số logic game
        // const BRIDGE_START = 150;
        // const BRIDGE_END = 1050;
        const SPEED_CONSTANT = 0.11;
        const MAX_MOVE_ENERGY = 100;
        const WIND_FACTOR = 0.005;

        // --- GLOBAL GAME STATE ---
        let cameraX = 0;
        let cameraY = MAP_HEIGHT - SCREEN_H;
        let isDragging = false;
        let startDragX = 0, startDragY = 0;
        let initialCameraX = 0, initialCameraY = 0;

        let gameState = 'WAITING';
        let isPaused = false; 
        let turn = 'PLAYER';
        let wind = 0;
        
        let player = null; 
        let player2 = null;

        let charging = false;
        let currentPower = 0;
        let keys = {};
        let activeSkill = null;

        let skill1Used = false;
        let skill2Used = false;
        let skill3Used = false;
        
        let skill4Uses = 2; 
        let supplyDrops = [];
        let activeSupplyDrop = null; 

        let aiAccuracyMin = 0.6;
        let aiAccuracyMax = 0.7;
        let turnDuration = 20;
        let timeLeft = 0;
        let timerInterval = null;
        let currentModeName = 'DỄ';
        let lastAiMessage = "";
        let playerLandedHit = false;

        let bullets = [];
        let particles = [];
        let floatingTexts = [];
        // let waterOffset = 0; // ĐÃ XÓA VÌ CHUYỂN VÀO CLASS MAP

        // --- UI ELEMENTS ---
        const elWind = document.getElementById('wind-val');
        const elAngle = document.getElementById('angle-val');
        const elHp = document.getElementById('hp-val');
        const elMoveBar = document.getElementById('move-bar');
        const elPowerBar = document.getElementById('power-bar');
        const elLastPowerMarker = document.getElementById('last-power-marker');
        const elTurnText = document.getElementById('turn-text');
        const elModeText = document.getElementById('mode-text');
        const elTimerText = document.getElementById('timer-text');
        const elChatHistory = document.getElementById('chat-history');
        const elEndScreen = document.getElementById('end-screen');
        const elEndMsg = document.getElementById('end-msg');
        const btnSkill1 = document.getElementById('btn-skill-1');
        const btnSkill2 = document.getElementById('btn-skill-2');
        const btnSkill3 = document.getElementById('btn-skill-3');
        const btnSkill4 = document.getElementById('btn-skill-4');
        const btnFire = document.getElementById('btn-fire');
        const startMenu = document.getElementById('start-menu');
        const btnPauseText = document.getElementById('btn-pause-text');
        const pauseMenu = document.getElementById('pause-menu');

        const mmCanvas = document.getElementById('minimapCanvas');
        const mmCtx = mmCanvas.getContext('2d');
        const mmContainer = document.getElementById('minimap-container');
        const mmOverlay = document.getElementById('minimap-overlay');
        const btnToggleMap = document.getElementById('btn-toggle-map');
        const btnCloseMap = document.getElementById('btn-close-map');
        
        // const MINIMAP_WIDTH = 150;
        // const MAP_SCALE = MINIMAP_WIDTH / MAP_WIDTH;
        // const MINIMAP_HEIGHT = MAP_HEIGHT * MAP_SCALE;
        const MINIMAP_WIDTH = 150;
        let MAP_SCALE = MINIMAP_WIDTH / MAP_WIDTH;      // Đổi thành let
        let MINIMAP_HEIGHT = MAP_HEIGHT * MAP_SCALE;    // Đổi thành let
        
        const dpr = window.devicePixelRatio || 1;
        mmCanvas.width = MINIMAP_WIDTH * dpr;
        mmCanvas.height = MINIMAP_HEIGHT * dpr;
        // mmCanvas.style.width = MINIMAP_WIDTH + 'px';
        // mmCanvas.style.height = MINIMAP_HEIGHT + 'px';
        document.getElementById('minimap-container').style.height = MINIMAP_HEIGHT + 'px';

        // ==========================================
        // === OOP CLASSES: BULLETS & TANKS ===
        // ==========================================

        // --- BASE BULLET ---
        class BaseBullet {
            constructor(x, y, angle, power, damage, gravity = GRAVITY, windResist = 1.0) {
                this.x = x; 
                this.y = y;
                this.startX = x; // Lưu vị trí bắt đầu để tính khoảng cách
                
                // [THAY ĐỔI] Base Damage cố định (ví dụ: 30)
                // Nếu không truyền damage thì mặc định là 0 để tránh NaN
                this.damage = damage || 0;

                const rad = angle * Math.PI / 180;
                this.vx = Math.cos(rad) * (power * SPEED_CONSTANT);
                this.vy = -Math.sin(rad) * (power * SPEED_CONSTANT);
                
                this.gravityVal = gravity;    
                this.windFactor = windResist; 
                this.isDead = false;          
                this.history = [];
                this.historyMax = 10;
            }

            get shouldCameraTrack() { return !this.isDead && this.y > -1000 && this.y < MAP_HEIGHT + 200; }

            update() {
                this.vx += wind * WIND_FACTOR * this.windFactor;
                this.vy += this.gravityVal;
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.x < -100 || this.x > MAP_WIDTH + 100 || this.y > MAP_HEIGHT) this.isDead = true;
                this.history.push({ x: this.x, y: this.y });
                if (this.history.length > this.historyMax) this.history.shift();
            }

            draw(ctx) { }

            // [HÀM TÍNH DAMAGE CHUẨN]
            // --- TÌM TRONG CLASS: BaseBullet ---

            calculateDamage(target) {
                // 1. Lấy damage gốc
                let dmg = this.damage; 
                
                // An toàn: Nếu damage lỗi thì gán mặc định
                if (isNaN(dmg)) dmg = 20;

                // 2. Random nhỏ (0 - 5) để tạo biến số
                dmg += Math.floor(Math.random() * 6);

                let bonusMultiplier = 1.0;

                // --- [CHỈNH SỬA THEO YÊU CẦU] ---
                
                // 3. Bonus Góc Cao (High Angle)
                // Cũ: >9 (+30%), >7 (+15%)
                // Mới: >9 (+15%), >7 (+5%) -> Giảm mạnh để tránh one-shot
                if (this.vy > 9) {
                    bonusMultiplier += 0.15;      // 15% (Cao nhất)
                } else if (this.vy > 7) {
                    bonusMultiplier += 0.05;      // 5% (Khuyến khích nhẹ)
                }

                // 4. Bonus Khoảng Cách (Long Distance)
                // Cũ: >800 (+20%)
                // Mới: >800 (+10%)
                if (this.startX !== undefined) {
                    let dist = Math.abs(this.x - this.startX);
                    if (dist > 800) {
                        bonusMultiplier += 0.1;   // 10%
                    }
                }

                // Tính toán damage cuối cùng
                return Math.floor(dmg * bonusMultiplier);
            }

            onHit(target) { createExplosion(this.x, this.y, 20, 'fire'); }

            handleCollision(target, shooter) {
                SoundManager.playExplosion();
                
                let finalDmg = this.calculateDamage(target);
                
                // Buff damage x2
                if (shooter && shooter.damageBuff) finalDmg *= 2;
                
                // Buff damage Khổng lồ (Fix logic scale âm của Player 2)
                if (shooter && Math.abs(shooter.scale) > 1.0) finalDmg = Math.floor(finalDmg * 1.5);

                // Hiển thị text damage
                if (target === shooter) {
                    showFloatingText("TỰ HỦY!", target.x, target.y - 70, '#ff0000');
                } else if (this.vy > 9) {
                    showFloatingText("CHÍ MẠNG!", target.x, target.y - 80, '#ff3d00');
                } else if (this.startX !== undefined && Math.abs(this.x - this.startX) > 800) {
                    showFloatingText("SNIPER!", target.x, target.y - 80, '#d500f9');
                }

                target.takeDamage(finalDmg);
                this.onHit(target);
            }
        }

        // --- Artillery BULLET ---
        // --- COPY ĐÈ LÊN CLASS ArtilleryBullet CŨ ---
        class ArtilleryBullet extends BaseBullet {
            // Thêm tham số baseDmg vào cuối
            constructor(x, y, angle, power, windVal, baseDmg) {
                // Nếu baseDmg bị thiếu hoặc lỗi, mặc định là 20
                let safeDmg = (baseDmg && baseDmg > 0) ? baseDmg : 20;

                // Truyền safeDmg lên BaseBullet
                super(x, y, angle, power, safeDmg, GRAVITY, 1.0); 
                
                this.windEffect = windVal * WIND_FACTOR; 
                this.isPotentialHighShot = (angle >= 40 && angle <= 140) && (power > 90);
                this.isSuperCharged = false;
                this.timer = 0;
            }

            update() {
                this.timer++;
                super.update(); // Gọi update của BaseBullet (đã có startX để tính damage xa)
                
                if (this.isPotentialHighShot && this.vy > 0 && !this.isSuperCharged) {
                    this.isSuperCharged = true;
                }
                
                // Hiệu ứng hạt
                if (this.timer % 2 === 0) {
                    let pType = this.isSuperCharged ? 'fire' : 'spark';
                    particles.push(new Particle(this.x, this.y, pType, { 
                        vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, life: 0.5, size: Math.random() * 2 + 1 
                    }));
                }
            }

            calculateDamage(target) {
                // Gọi hàm tính damage chuẩn từ BaseBullet (bao gồm random, khoảng cách...)
                let dmg = super.calculateDamage(target);
                
                // Nếu damage trả về bị lỗi (NaN hoặc 0), ép về 20
                if (!dmg || isNaN(dmg)) dmg = 20;

                // Cộng thêm bonus nòng đỏ (Super Charge)
                if (this.isSuperCharged) {
                    dmg = Math.floor(dmg * 1.4); // Tăng 40%
                }
                return dmg;
            }

            onHit(target) {
                let size = this.isSuperCharged ? 40 : 20;
                createExplosion(this.x, this.y, size, 'fire');
            }

            draw(ctx) {
                ctx.save();
                // Vẽ đuôi đạn
                if (this.history.length > 2) {
                    ctx.beginPath(); 
                    ctx.moveTo(this.history[0].x, this.history[0].y);
                    for (let i = 1; i < this.history.length; i++) { ctx.lineWidth = 1 + (i / this.history.length) * 4; ctx.lineTo(this.history[i].x, this.history[i].y); }
                    let grad = ctx.createLinearGradient(this.history[0].x, this.history[0].y, this.x, this.y);
                    if (this.isSuperCharged) { grad.addColorStop(0, 'rgba(255, 50, 0, 0)'); grad.addColorStop(1, 'rgba(255, 200, 0, 0.8)'); } else { grad.addColorStop(0, 'rgba(255, 255, 255, 0)'); grad.addColorStop(1, 'rgba(255, 255, 255, 0.6)'); }
                    ctx.strokeStyle = grad; ctx.stroke();
                }
                // Vẽ đầu đạn
                ctx.translate(this.x, this.y); 
                let rot = Math.atan2(this.vy, this.vx); ctx.rotate(rot);
                ctx.shadowBlur = this.isSuperCharged ? 20 : 10; ctx.shadowColor = this.isSuperCharged ? '#ff3d00' : '#ffa000'; ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = this.isSuperCharged ? '#ffeb3b' : '#fff'; 
                ctx.beginPath(); let stretch = Math.min(2.0, 1.0 + Math.sqrt(this.vx * this.vx + this.vy * this.vy) * 0.05); ctx.scale(stretch, 0.6); ctx.arc(0, 0, 5, 0, Math.PI * 2); ctx.fill(); 
                ctx.restore();
            }
        }

        // --- Machine Gun Bullet ---
        class MachineGunBullet extends BaseBullet {
            constructor(x, y, angle, power, windVal, sequenceIndex) {
                super(x, y, angle, power * 1.0, 0, 0.12, 0.4);
                this.oriX = this.x; this.oriY = this.y;
                this.activationDelay = sequenceIndex * 6;
                if (this.activationDelay > 0) { this.y = -5000; }
                this.damage = 0; 
            }

            get shouldCameraTrack() {
                if (this.activationDelay > 0) return false;
                return super.shouldCameraTrack;
            }

            update() {
                if (this.activationDelay > 0) {
                    this.activationDelay--;
                    if (this.activationDelay <= 0) { this.x = this.oriX; this.y = this.oriY; SoundManager.playShoot(); }
                    return;
                }
                super.update();
            }
            onHit(target) { createExplosion(this.x, this.y, 20, 'fire'); }
            draw(ctx) {
                if (this.y < -1000) return;
                ctx.save(); ctx.translate(this.x, this.y); let rot = Math.atan2(this.vy, this.vx); ctx.rotate(rot);
                let tailGrad = ctx.createLinearGradient(0, 0, -30, 0); tailGrad.addColorStop(0, "rgba(255, 215, 0, 0.9)"); tailGrad.addColorStop(1, "rgba(255, 69, 0, 0)");
                ctx.fillStyle = tailGrad; ctx.beginPath(); ctx.moveTo(0, 2); ctx.lineTo(-30, 0); ctx.lineTo(0, -2); ctx.fill();
                ctx.shadowBlur = 10; ctx.shadowColor = '#FFD700';
                let bulletGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 6); bulletGrad.addColorStop(0, "#FFFFFF"); bulletGrad.addColorStop(0.4, "#FFFF00"); bulletGrad.addColorStop(1, "#FF8C00");
                ctx.fillStyle = bulletGrad; ctx.beginPath(); ctx.ellipse(0, 0, 10, 3.5, 0, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 1; ctx.stroke(); ctx.restore();
            }
        }

        // --- Laser BULLET ---
        class LaserBullet extends BaseBullet {
            constructor(x, y, angle, power, windVal, type = 'NORMAL', targetObj = null) {
                super(x, y, angle, power, 0); 
                this.type = type; 
                this.isDead = false;
                this.targetObj = targetObj; 
                this.history = [];

                if (type === 'SATELLITE') {
                    this.x = x; this.y = y; this.vx = 0; this.vy = 0; this.speed = 0; this.life = 1000; this.color = '#d500f9';
                }
                else if (type === 'TRIGGER') {
                    const rad = angle * Math.PI / 180; const spawnDist = 60;
                    this.x = x + Math.cos(rad) * spawnDist; this.y = (y - 14) - Math.sin(rad) * spawnDist;
                    this.speed = 25; this.vx = Math.cos(rad) * this.speed; this.vy = -Math.sin(rad) * this.speed;
                    this.damage = 10; this.width = 3; this.color = '#fff';
                }
                //check type === 'AUTO_BEAM'
                else if (type === 'AUTO_BEAM') {
                    this.x = x; this.y = y; this.speed = 30; 
                    if (targetObj) {
                        let dx = targetObj.x - x; let dy = (targetObj.y - 20) - y; let dist = Math.sqrt(dx*dx + dy*dy);
                        this.vx = (dx/dist) * this.speed; this.vy = (dy/dist) * this.speed;
                    } else { this.vx = 0; this.vy = 0; }
                    
                    // [MACRO] Skill 2 (Vệ tinh): 95 Dame gốc -> Tổng ~95-100
                    this.damage = 75; 
                    this.width = 10; this.color = '#d500f9';
                }
                else {
                    const rad = angle * Math.PI / 180;
                    // --- CÁI IF 1: TÍNH VỊ TRÍ (GIỮ NGUYÊN) ---
                    if (type === 'SPLIT_CHILD') { 
                        this.x = x; this.y = y; 
                    } else { 
                        const spawnDist = 65; 
                        this.x = x + Math.cos(rad) * spawnDist; 
                        this.y = (y - 14) - Math.sin(rad) * spawnDist; 
                    }
                    this.state = 'UP'; this.speed = 10; 
                    // --- CÁI IF 2: TÍNH SÁT THƯƠNG (ĐÃ SỬA THEO MACRO) ---
                    if (type === 'SPLIT_CHILD') { 
                        // [MACRO] Skill 1 tia con: 25 dame
                        this.damage = 25; 
                        this.width = 2; 
                        this.color = '#00e676'; 
                    } else { 
                        // Đạn mẹ bay lên trời (không gây dame)
                        this.damage = 0; 
                        this.width = 4; 
                        this.color = '#00e5ff'; 
                    }
                    if (type !== 'SPLIT_CHILD') {
                        let flightPower = power * 1.3; 
                        let simVx = Math.cos(rad) * flightPower * 0.15; let simVy = Math.sin(rad) * flightPower * 0.15; 
                        let timeToPeak = simVy / GRAVITY; if (timeToPeak < 5) timeToPeak = 10;
                        let windShift = windVal * timeToPeak * 0.8; 
                        this.peakX = this.x + (simVx * timeToPeak) + windShift;
                        this.peakY = this.y - (simVy * timeToPeak) + (0.5 * GRAVITY * timeToPeak * timeToPeak);
                        if (this.peakY < -400) this.peakY = -400; 
                        this.landX = this.peakX + (simVx * timeToPeak) + windShift; this.landY = currentMap.groundY + 50; 
                        this.setTarget(this.peakX, this.peakY);
                    } else { this.state = 'DOWN'; }
                }
                this.history = [{x: this.x, y: this.y}];
            }

            get shouldCameraTrack() {
                if (this.type === 'SATELLITE') return false;
                return super.shouldCameraTrack;
            }

            setTarget(tx, ty) {
                this.targetX = tx; this.targetY = ty;
                let dx = tx - this.x; let dy = ty - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy); if (dist === 0) dist = 1;
                this.vx = (dx / dist) * this.speed; this.vy = (dy / dist) * this.speed;
            }

            update() {
                if (this.type === 'SATELLITE') return;
                if (this.type === 'TRIGGER') {
                    this.x += this.vx; this.y += this.vy; this.history.push({x: this.x, y: this.y}); if(this.history.length > 10) this.history.shift();
                    for (let i = 0; i < bullets.length; i++) {
                        let b = bullets[i];
                        if (b.type === 'SATELLITE' && !b.isDead) {
                            if (Math.hypot(this.x - b.x, this.y - b.y) < 40) {
                                this.isDead = true; b.isDead = true; 
                                SoundManager.playExplosion(); 
                                createExplosion(b.x, b.y, 30, 'shockwave');
                                let enemy = (turn.includes('PLAYER1')) ? player2 : player;
                                bullets.push(new LaserBullet(b.x, b.y, 0, 0, 0, 'AUTO_BEAM', enemy)); 
                                showFloatingText("KẾT NỐI!", b.x, b.y - 50, '#d500f9'); 
                                return;
                            }
                        }
                    }
                    if (this.x < -200 || this.x > MAP_WIDTH + 200 || this.y > MAP_HEIGHT + 200) this.isDead = true;
                    return;
                }
                if (this.type === 'AUTO_BEAM') {
                    this.x += this.vx; this.y += this.vy; this.history.push({x: this.x, y: this.y}); if(this.history.length > 20) this.history.shift();
                    if (this.x < -200 || this.x > MAP_WIDTH + 200 || this.y > MAP_HEIGHT + 200) this.isDead = true; return;
                }

                this.history.push({x: this.x, y: this.y}); if (this.history.length > 30) this.history.shift(); 
                this.x += this.vx; this.y += this.vy;

                if (this.state === 'UP') {
                    let distToPeak = Math.hypot(this.x - this.peakX, this.y - this.peakY);
                    if (distToPeak <= this.speed) {
                        this.x = this.peakX; this.y = this.peakY;
                        if (this.type === 'SPLIT_PARENT') { this.splitBullets(this.peakX, this.peakY); this.isDead = true; return; }
                        this.state = 'DOWN'; this.setTarget(this.landX, this.landY);
                    }
                } 
                if (this.x < -200 || this.x > MAP_WIDTH + 200 || this.y > MAP_HEIGHT + 100) this.isDead = true;
            }

            splitBullets(ox, oy) {
                SoundManager.playShoot(); createExplosion(ox, oy, 15, 'spark');
                let tx = this.landX; let ty = this.landY; let spread = [-300, -100, 100, 300];
                spread.forEach((offset) => {
                    let child = new LaserBullet(ox, oy, 0, 0, 0, 'SPLIT_CHILD'); child.setTarget(tx + offset, ty); child.history = [{x: ox, y: oy}]; bullets.push(child);
                });
            }
            
            calculateDamage(target) { return this.damage; }
            onHit(target) { createExplosion(this.x, this.y, (this.type==='AUTO_BEAM'?40:20), 'spark'); }

            draw(ctx) {
                ctx.save();
                if (this.type === 'SATELLITE') {
                    ctx.translate(this.x, this.y); ctx.translate(0, Math.sin(Date.now() / 300) * 5); this.drawDiamondShape(ctx, 2.0); ctx.restore(); return;
                }
                if (this.history.length < 2) { ctx.restore(); return; }
                if (this.type === 'AUTO_BEAM') {
                    ctx.shadowBlur = 20; ctx.shadowColor = '#d500f9'; ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath(); ctx.moveTo(this.history[0].x, this.history[0].y); for (let i = 1; i < this.history.length; i++) ctx.lineTo(this.history[i].x, this.history[i].y); ctx.lineTo(this.x, this.y);
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 4; ctx.stroke(); ctx.strokeStyle = '#d500f9'; ctx.lineWidth = 10; ctx.globalAlpha = 0.5; ctx.stroke(); ctx.restore(); return;
                }
                if (this.state === 'DOWN' && this.type === 'NORMAL') {
                    ctx.save(); if (this.peakX !== undefined && this.peakY !== undefined) { ctx.translate(this.peakX, this.peakY); this.drawDiamondShape(ctx, 1.2); } ctx.restore();
                }
                ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.globalCompositeOperation = 'lighter';
                ctx.beginPath(); ctx.moveTo(this.history[0].x, this.history[0].y); for (let i = 1; i < this.history.length; i++) ctx.lineTo(this.history[i].x, this.history[i].y); ctx.lineTo(this.x, this.y);
                let grad = ctx.createLinearGradient(this.history[0].x, this.history[0].y, this.x, this.y); grad.addColorStop(0, 'rgba(255, 255, 255, 0)'); grad.addColorStop(1, this.color);
                ctx.strokeStyle = grad; ctx.lineWidth = this.width; ctx.stroke(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x, this.y, this.width, 0, Math.PI*2); ctx.fill(); ctx.restore();
            }

            drawDiamondShape(ctx, scale) {
                ctx.scale(scale, scale); const colorLight = '#4fc3f7'; const colorDark = '#0288d1'; const colorBorder = '#e1f5fe';
                ctx.beginPath(); ctx.moveTo(-12, -2); ctx.lineTo(12, -2); ctx.lineTo(0, 16); ctx.closePath(); ctx.fillStyle = colorDark; ctx.fill(); ctx.lineWidth = 1; ctx.strokeStyle = colorBorder; ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-8, -10); ctx.lineTo(8, -10); ctx.lineTo(12, -2); ctx.lineTo(-12, -2); ctx.closePath(); ctx.fillStyle = colorLight; ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-8, -10); ctx.lineTo(8, -10); ctx.lineTo(4, -2); ctx.lineTo(-4, -2); ctx.closePath(); ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; ctx.fill();
                ctx.beginPath(); ctx.moveTo(-12, -2); ctx.lineTo(0, 16); ctx.moveTo(12, -2); ctx.lineTo(0, 16); ctx.moveTo(0, -2); ctx.lineTo(0, 16); ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.stroke();
            }
        }

        
        class BoomerangBullet extends BaseBullet {
            constructor(x, y, angle, power, windVal, damage, isSkill2 = false) {
                super(x, y, angle, power, damage, GRAVITY, 0.3); 
                
                this.rotAngle = 0; 
                this.isSkill2 = isSkill2;
                this.initialAngle = angle;
                this.lifeTime = 0;

                this.accelX = 0;         
                this.gravityVal = GRAVITY;
                this.turnStartFrame = 0; 

                if (this.initialAngle > 70 && this.initialAngle < 110) {
                    this.gravityVal = GRAVITY * 0.35; 
                    this.accelX = 0; 
                } else {
                    this.vx *= 1.3;
                    this.vy *= 1.3;
                    this.turnStartFrame = 55; 
                    let hookStrength = 0.25; 
                    let isShootingRight = (this.initialAngle < 90);
                    if (isShootingRight) { this.pendingAccelX = -hookStrength; } 
                    else { this.pendingAccelX = hookStrength; }
                }

                this.historyMax = 35;
            }

            update() {
                this.vx += wind * WIND_FACTOR * this.windFactor;
                this.vy += this.gravityVal;
                this.lifeTime++;

                if (this.pendingAccelX && this.lifeTime > this.turnStartFrame) {
                    this.vx += this.pendingAccelX;
                }

                this.x += this.vx;
                this.y += this.vy;
                
                if (this.x < -300 || this.x > MAP_WIDTH + 300 || this.y > MAP_HEIGHT) {
                    this.isDead = true;
                }
                
                this.history.push({ x: this.x, y: this.y });
                if (this.history.length > this.historyMax) this.history.shift();

                this.rotAngle += 0.5; 
            }

            draw(ctx) {
                if (this.history.length < 2) return;
                ctx.save();
                
                ctx.beginPath();
                ctx.moveTo(this.history[0].x, this.history[0].y);
                for (let i = 1; i < this.history.length - 1; i++) {
                    let p0 = this.history[i];
                    let p1 = this.history[i+1];
                    let midX = (p0.x + p1.x) / 2;
                    let midY = (p0.y + p1.y) / 2;
                    ctx.quadraticCurveTo(p0.x, p0.y, midX, midY);
                }
                ctx.lineTo(this.x, this.y);
                
                let trailGrad = ctx.createLinearGradient(this.history[0].x, this.history[0].y, this.x, this.y);
                trailGrad.addColorStop(0, 'rgba(118, 255, 3, 0)');   
                trailGrad.addColorStop(0.5, 'rgba(118, 255, 3, 0.3)');
                trailGrad.addColorStop(1, 'rgba(118, 255, 3, 0.9)'); 
                
                ctx.lineCap = 'round';
                ctx.lineWidth = this.isSkill2 ? 8 : 4; 
                ctx.strokeStyle = trailGrad;
                ctx.stroke();

                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotAngle);
                ctx.shadowBlur = 15; ctx.shadowColor = '#76ff03';

                ctx.beginPath();
                ctx.fillStyle = this.isSkill2 ? '#ccff90' : '#76ff03'; 
                ctx.strokeStyle = '#33691e'; ctx.lineWidth = 2;
                const outerRadius = 14; const innerRadius = 5; const spikes = 3;
                for (let i = 0; i < spikes * 2; i++) {
                    const r = (i % 2 === 0) ? outerRadius : innerRadius;
                    const a = (Math.PI * i) / spikes;
                    const x = Math.cos(a) * r; const y = Math.sin(a) * r;
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.closePath(); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill();
                ctx.restore();
            }
            
            calculateDamage(target) { let dmg = super.calculateDamage(target); if (this.isSkill2) dmg *= 2; return dmg; }

            onHit(target) {
                createExplosion(this.x, this.y, 25, 'smoke'); 
                for(let i=0; i<12; i++) {
                    particles.push(new Particle(this.x, this.y, 'spark', { vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12, life: 0.7, size: 3 }));
                }
            }
        }

        // --- COMMONDO TANK BULLET ---
        class AirBombBullet extends BaseBullet {
            constructor(x, y, targetY, damage, isNuke = false) {
                super(x, y, 90, 0, 0, 0.3, 0); 
                this.vx = 0; 
                this.vy = 5; 
                this.targetY = targetY; 
                this.damage = damage;   
                this.isNuke = isNuke;   
                this.color = '#ff3d00';
            }

            update() {
                this.y += this.vy;
                this.vy += 0.2; 
                particles.push(new Particle(this.x, this.y - 10, 'smoke', { life: 0.3, size: (this.isNuke ? 5 : 2), vy: -2 }));

                if (this.y >= this.targetY) {
                    this.isDead = true;
                    this.onHit(null); 
                }
            }

            handleCollision(target, shooter) {
                this.onHit(target); 
                this.isDead = true; 
            }

            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                if (this.isNuke) {
                    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI*2); ctx.fill(); 
                    ctx.strokeStyle = '#ffeb3b'; ctx.lineWidth = 2; ctx.stroke();
                    ctx.fillStyle = '#ffeb3b'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center'; ctx.fillText('☢', 0, 4);
                    ctx.fillStyle = '#333'; ctx.fillRect(-10, -18, 20, 6);
                } else {
                    ctx.fillStyle = '#37474f'; ctx.beginPath(); ctx.moveTo(0, 10); ctx.lineTo(-5, -5); ctx.arc(0, -5, 5, Math.PI, 0); ctx.lineTo(5, -5); ctx.fill();
                    ctx.fillStyle = this.color; ctx.fillRect(-6, -10, 12, 3);
                }
                ctx.restore();
            }

            onHit(target) {
                SoundManager.playExplosion();
                if (this.isNuke) {
                    createExplosion(this.x, this.y, 80, 'fire'); 
                    for(let i=0; i<30; i++) particles.push(new Particle(this.x + (Math.random()-0.5)*60, this.y + (Math.random()-0.5)*40, 'smoke', { size: 10 + Math.random()*10, life: 2.0, vy: -1 - Math.random()*2 }));
                    particles.push(new Particle(this.x, this.y, 'shockwave', { size: 10, decay: 0.05 }));
                    showFloatingText(`HỦY DIỆT!`, this.x, this.y-120, '#d50000');
                    
                    // [SỬA LỖI TẠI ĐÂY]: Đổi [player, ai] thành [player, player2]
                    let targets = [player, player2]; 
                    
                    targets.forEach(t => {
                        // Thêm kiểm tra t (để tránh lỗi nếu player2 chưa khởi tạo xong)
                        if (t && t.hp > 0 && Math.abs(t.x - this.x) < 60) { 
                            t.takeDamage(this.damage);
                        }
                    });
                } else {
                    createExplosion(this.x, this.y, 25, 'fire');
                    
                    // [SỬA LỖI TẠI ĐÂY]: Đổi [player, ai] thành [player, player2]
                    let targets = [player, player2];

                    targets.forEach(t => {
                        if (t && t.hp > 0 && Math.abs(t.x - this.x) < 30 && Math.abs(t.y - this.y) < 40) {
                            t.takeDamage(this.damage);
                        }
                    });
                }
            }
        }

        class BombSpawner extends BaseBullet {
            constructor(x, targetY, type, distance) {
                super(x, -5000, 0, 0, 0); 
                this.spawnX = x;
                this.targetY = targetY;
                this.type = type;
                this.distance = distance; 
                this.timer = 0;
                this.isSpawner = true; 
            }

            get shouldCameraTrack() { return false; }
            calculateDamage() { return 0; }

            getDamage(min, max) {
                let maxDist = 800; 
                let factor = Math.min(1, this.distance / maxDist);
                return Math.floor(min + (max - min) * factor);
            }

            update() {
                this.timer++;

                if (this.type === 'CARPET') {
                    // SKILL 1: RẢI THẢM
                    if (this.timer % 5 === 0 && this.timer <= 25) {
                        let index = (this.timer / 5) - 1; 
                        let offset = (index - 2) * 40; 
                        // [MACRO] 5 quả bom, mỗi quả 18 dame
                        let dmg = 18; 
                        bullets.push(new AirBombBullet(this.spawnX + offset, -100 - Math.abs(offset), this.targetY, dmg));
                    }
                    if (this.timer > 30) this.isDead = true; 
                }
               else if (this.type === 'NUKE') {
                    if (this.timer === 20) { 
                        // [NERF] Giảm từ 90 -> 70.
                        // Nuke nổ rất rộng, dễ trúng, giảm dame để tránh quét sạch map quá nhanh.
                        let dmg = 70; 
                        bullets.push(new AirBombBullet(this.spawnX, -100, this.targetY, dmg, true));
                        showFloatingText("NUKE SẮP NỔ!", this.spawnX, -50, '#d50000');
                    }
                    if (this.timer > 30) this.isDead = true;
                }
                else {
                    // BẮN THƯỜNG
                    if (this.timer === 20) {
                        // [MACRO] 1 quả bom thường, 30 dame
                        let dmg = 30;
                        bullets.push(new AirBombBullet(this.spawnX, -100, this.targetY, dmg));
                        showFloatingText("BOM ĐANG TỚI!", this.spawnX, -50, '#ff3d00');
                    }
                    if (this.timer > 30) this.isDead = true;
                }
            }

            draw(ctx) { }
            onHit() { }
        }

        class SignalFlareBullet extends BaseBullet {
            constructor(x, y, angle, power, windVal, type = 'NORMAL') {
                super(x, y, angle, power, 0, GRAVITY, 0.8);
                this.startX = x; 
                this.type = type; 
                // [MACRO] Pháo hiệu chỉ gây 5 dame (lấy hiệu ứng là chính)
                this.damage = 5; 
                this.mainColor = (type === 'CARPET') ? '#ff1744' : '#ffea00';
            }
            
            draw(ctx) {
                if (this.history.length < 2) return;
                ctx.save();
                let grad = ctx.createLinearGradient(this.x, this.y, this.history[0].x, this.history[0].y);
                grad.addColorStop(0, 'rgba(255, 255, 255, 0.6)'); grad.addColorStop(1, 'rgba(100, 100, 100, 0)');   
                ctx.beginPath(); ctx.moveTo(this.history[0].x, this.history[0].y);
                for(let i=1; i<this.history.length - 1; i++) {
                    let p0 = this.history[i]; let p1 = this.history[i+1];
                    ctx.quadraticCurveTo(p0.x, p0.y, (p0.x + p1.x)/2, (p0.y + p1.y)/2);
                }
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = grad; ctx.lineWidth = (this.type === 'CARPET') ? 4 : 2; 
                ctx.lineCap = 'round'; ctx.stroke();
                
                ctx.translate(this.x, this.y);
                let rot = Math.atan2(this.vy, this.vx); ctx.rotate(rot);
                ctx.fillStyle = '#555'; ctx.fillRect(-6, -3, 6, 6); 
                ctx.shadowBlur = 15; ctx.shadowColor = this.mainColor;
                ctx.fillStyle = this.mainColor; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill(); 
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 0, 2, 0, Math.PI*2); ctx.fill(); 
                ctx.restore();
            }

            onHit(target) {
                if (target) {
                    createExplosion(this.x, this.y, 5, 'smoke');
                    showFloatingText("KHÓA MỤC TIÊU!", this.x, this.y - 70, this.mainColor);
                    let dist = Math.abs(this.x - this.startX);
                    bullets.push(new BombSpawner(target.x, target.y, this.type, dist));
                } else {
                    createExplosion(this.x, this.y, 5, 'smoke');
                    showFloatingText("TRƯỢT...", this.x, this.y - 40, '#aaa');
                }
            }
        }

        // --- BASE TANK SYSTEM ---
        class BaseTank {
            constructor(x, color, name, isAI) {
                this.x = x;
                this.y = currentMap.groundY - 14;
                this.color = color; this.name = name; this.isAI = isAI;
                this.hp = 300; this.maxHp = 300; 
                this.angle = isAI ? 135 : 45; 
                if (name === 'Player 2') { this.angle = 135; this.scale = -1; } // Mặc định quay đầu cho P2
                
                this.hitTimer = 0;
                this.isParachuting = false; 
                
                this.moveEnergy = MAX_MOVE_ENERGY; 
                this.damageBuff = false;
                this.extraShot = false; 
                this.isShielded = false; 
                this.isDead = false;
                this.scale = 1.0; 
                if (name === 'Player 2') this.scale = -1.0; // Fix scale cho P2
                
                this.w = 48; 
                this.bodyAngle = 0; 
                this.fallSpeed = 0; 
                this.lastStuckTime = 0;

                // [MỚI] THÊM TRẠNG THÁI KỸ NĂNG RIÊNG CHO TỪNG XE
                this.skill1Used = false;
                this.skill2Used = false;
                this.skill3Used = false;
                this.skill4Uses = 2; // Mỗi người có 2 lần gọi thính
            }

            // 1. Hàm Update: Xử lý trọng lực (rơi) và góc nghiêng xe
            update() {
                if (this.isParachuting) return;

                // A. XỬ LÝ TRỌNG LỰC (Rơi tự do)
                let groundH = currentMap.getHeightAt(this.x);
                let targetY = groundH - 14; 

                if (this.y < targetY) {
                    this.fallSpeed += 0.5; 
                    this.y += this.fallSpeed;
                    
                    if (this.y > targetY) {
                        this.y = targetY;
                        this.fallSpeed = 0;
                    }
                } else {
                    this.y = targetY; 
                    this.fallSpeed = 0;
                }

                // [MỚI] KIỂM TRA TỬ VONG NẾU RƠI KHỎI MAP
                // Nếu rơi sâu quá mép dưới màn hình -> Chết luôn
                if (this.y > currentMap.height + 50 && !this.isDead) {
                    this.hp = 0;
                    this.onDeath();
                    // Nếu là người chơi chết thì báo Game Over ngay
                    if (!this.isAI && gameState !== 'ENDED') {
                        setTimeout(() => endGame('GAME OVER', '#ff5252'), 1000);
                    } else if (this.isAI && gameState !== 'ENDED') {
                        setTimeout(() => endGame('YOU WIN', '#00e676'), 1000);
                    }
                }

                // B. CẬP NHẬT GÓC NGHIÊNG THÂN XE
                // let wheelOffset = 15;
                // let yBack = currentMap.getHeightAt(this.x - wheelOffset);
                // let yFront = currentMap.getHeightAt(this.x + wheelOffset);
                // let targetAngle = Math.atan2(yFront - yBack, wheelOffset * 2);
                // this.bodyAngle += (targetAngle - this.bodyAngle) * 0.2;
                // B. CẬP NHẬT GÓC NGHIÊNG THÂN XE
                let wheelOffset = 15;
                // Lấy độ cao đất ở 2 điểm bánh xe
                let yBack = currentMap.getHeightAt(this.x - wheelOffset);
                let yFront = currentMap.getHeightAt(this.x + wheelOffset);
                // Tính góc dốc của mặt đất
                let slopeAngle = Math.atan2(yFront - yBack, wheelOffset * 2);
                // [FIX LỖI P2]: Nếu xe bị lật (scale < 0), ta phải đảo ngược góc nghiêng
                // Vì khi vẽ ctx.scale(-1, 1), góc xoay dương sẽ biến thành xoay ngược chiều kim đồng hồ
                if (this.scale < 0) {
                    slopeAngle = -slopeAngle;
                }
                // Làm mượt chuyển động nghiêng
                this.bodyAngle += (slopeAngle - this.bodyAngle) * 0.2;
            }
            
            onTurnStart() {
                this.moveEnergy = MAX_MOVE_ENERGY;
                this.damageBuff = false;
                // this.isShielded = false;
            }

            onTurnEnd() {
                // Cleanup
            }

            onDeath() {
                if (this.isDead) return;
                this.isDead = true;
                this.hp = 0; 

                this.originalColor = this.color; 
                this.color = '#424242'; 

                SoundManager.playExplosion();
                createExplosion(this.x, this.y, 40, 'fire'); 
                
                for(let i=0; i<15; i++) {
                    setTimeout(() => {
                        particles.push(new Particle(this.x + (Math.random()-0.5)*30, this.y, 'smoke', {
                            vx: (Math.random()-0.5)*1, 
                            vy: -Math.random()*2 - 1, 
                            life: 2.0, 
                            size: Math.random()*5 + 5
                        }));
                    }, i * 100); 
                }
                
                showFloatingText("HẠ GỤC!", this.x, this.y - 90, '#ff0000');
            }

            getAimSettings(currentSkillId) {
                return {
                    steps: 25,          
                    isSolid: false,     
                    colorStart: '#ffffff',
                    colorEnd: '#ffffff'
                };
            }

            activateShield() {
                this.isShielded = true;
                showFloatingText("KHIÊN BẢO VỆ!", this.x, this.y - 80, '#00ffff');
            }

            getPhysics() { return { gravity: GRAVITY, powerMulti: 1.0 }; }

            // [HÀM MỚI] Tính toán vị trí đầu nòng & góc bắn thực tế dựa trên độ nghiêng xe
            // getShootingParams() {
            //     // 1. Góc bắn thực tế (Radian) = Góc nòng (so với xe) - Góc nghiêng xe
            //     // Vì hệ toạ độ Canvas Y ngược, nên công thức là trừ
            //     const rad = (this.angle * Math.PI / 180) - this.bodyAngle;

            //     // 2. Tính toạ độ đầu nòng súng (Muzzle Position)
            //     // Pivot của súng nằm cách tâm xe: X=0, Y=-10
            //     // Xoay điểm Pivot này theo độ nghiêng thân xe (bodyAngle)
            //     // Công thức xoay vector: x' = x*cos(a) - y*sin(a)
            //     const pivotX = 0 * Math.cos(this.bodyAngle) - (-10) * Math.sin(this.bodyAngle);
            //     const pivotY = 0 * Math.sin(this.bodyAngle) + (-10) * Math.cos(this.bodyAngle);

            //     // 3. Từ Pivot, đi ra theo hướng nòng súng 44px
            //     const barrelLen = 44;
            //     const mx = Math.cos(rad) * barrelLen;
            //     const my = -Math.sin(rad) * barrelLen; // Y canvas ngược (lên là âm)

            //     return {
            //         x: pivotX + mx, // Offset X so với tâm xe
            //         y: pivotY + my, // Offset Y so với tâm xe
            //         rad: rad        // Góc bắn tuyệt đối (so với đường chân trời)
            //     };
            // }
            // --- THAY THẾ TOÀN BỘ HÀM getShootingParams() TRONG CLASS BaseTank ---

            getShootingParams() {
                // Kiểm tra xem xe có đang bị lật (như Player 2) hay không
                const isFlipped = this.scale < 0;

                // 1. Tính góc bắn thực tế
                // Nếu là P2 (Flipped), ta tính toán như P1 (hướng phải) rồi lật ngược kết quả sau
                // Góc visualAngle: Nếu P2 (135 độ) -> Visual là 45 độ (180 - 135)
                let visualAngle = isFlipped ? (180 - this.angle) : this.angle;
                
                // Đổi sang Radian
                let radVisual = (visualAngle * Math.PI / 180);

                // Trừ đi góc nghiêng xe (Lưu ý: bodyAngle đã được fix ở Bước 1 cho đúng chiều visual)
                let totalRad = radVisual - this.bodyAngle;

                // 2. Tính toạ độ đầu nòng súng (Muzzle) dựa trên góc Visual
                const barrelLen = 44;
                
                // Offset từ tâm xe đến chốt xoay súng (Pivot: 0, -10)
                // Xoay điểm Pivot theo độ nghiêng thân xe
                const pivotX = 0 * Math.cos(this.bodyAngle) - (-10) * Math.sin(this.bodyAngle);
                const pivotY = 0 * Math.sin(this.bodyAngle) + (-10) * Math.cos(this.bodyAngle);

                // Offset từ chốt xoay ra đầu nòng
                const mx = Math.cos(totalRad) * barrelLen;
                const my = -Math.sin(totalRad) * barrelLen; // Y canvas ngược

                // 3. KẾT QUẢ CUỐI CÙNG
                if (isFlipped) {
                    // [QUAN TRỌNG CHO P2]: 
                    // Vì P2 scale = -1, toạ độ X vật lý phải ngược lại so với tính toán Visual
                    // Góc bắn vật lý sẽ là (180 - VisualAngle)
                    return {
                        x: -(pivotX + mx),          // Đảo ngược X
                        y: pivotY + my,             // Y giữ nguyên
                        rad: Math.PI - totalRad     // Đảo ngược hướng bắn (180 độ - góc)
                    };
                } else {
                    // P1 tính toán bình thường
                    return {
                        x: pivotX + mx,
                        y: pivotY + my,
                        rad: totalRad
                    };
                }
            }

            calculateTrajectory(power, windVal, stepsLimit = 20) {
                // [FIX] Sử dụng thông số thực tế đã tính độ nghiêng
                const params = this.getShootingParams(); 
                const phys = this.getPhysics();
                let windResist = 1.0;
                
                // Vị trí bắt đầu là đầu nòng súng thực tế
                let sx = params.x;
                let sy = params.y;
                
                let speed = power * SPEED_CONSTANT * phys.powerMulti;
                // Vận tốc tính theo góc thực tế
                let vx = Math.cos(params.rad) * speed;
                let vy = -Math.sin(params.rad) * speed;

                let points = [{x: sx, y: sy}];
                let curX = sx, curY = sy;
                let steps = (typeof stepsLimit === 'number') ? stepsLimit : (stepsLimit ? 300 : 20);

                for (let i = 0; i < steps; i++) {
                    vx += windVal * WIND_FACTOR * windResist;
                    vy += phys.gravity;
                    curX += vx;
                    curY += vy;
                    points.push({x: curX, y: curY});
                    if (steps > 50 && currentMap.isGroundCollision(this.x + curX, this.y + curY)) break;
                }
                return { type: 'curve', points: points };
            }

            // [CẬP NHẬT] Hàm di chuyển thông minh: Dừng trước dốc & Bảo toàn năng lượng
            // [CẬP NHẬT] Hàm di chuyển chuẩn: Chỉ đổi X, không ép Y (để tránh giật khi ở hố)
            move(dir) {
                if (this.isParachuting) return;
                
                // Kiểm tra năng lượng (chỉ áp dụng cho người chơi)
                if (!this.isAI && this.moveEnergy <= 0) return;

                let nextX = this.x + dir * 2;
                nextX = Math.max(currentMap.minX, Math.min(currentMap.maxX, nextX));

                // 1. CHECK ĐỘ DỐC (Chống leo tường thẳng đứng)
                // Dùng look-ahead (nhìn trước) 10px để phát hiện dốc sớm
                let lookAhead = 10;
                let sensorX = nextX + (dir * lookAhead);
                
                let currentY = currentMap.getHeightAt(this.x);
                let nextY = currentMap.getHeightAt(nextX); // Độ cao tại vị trí chân mới
                let futureY = currentMap.getHeightAt(sensorX); // Độ cao phía trước

                // Tính độ dốc (Slope)
                // Slope > 0 nghĩa là đang leo lên (vì Y càng nhỏ càng cao)
                let slope = currentY - futureY; 
                let limitSlope = 15; // Giới hạn dốc leo được

                if (slope > limitSlope) {
                    // Nếu quá dốc -> Dừng lại
                    if (!this.isAI) {
                        // Hiện thông báo (có cooldown)
                        let now = Date.now();
                        if (now - this.lastStuckTime > 500) {
                            showFloatingText("DỐC QUÁ!", this.x, this.y - 70, '#ff9800');
                            this.lastStuckTime = now;
                        }
                    }
                    return; // Mắc kẹt, không cập nhật X
                }

                // 2. CẬP NHẬT VỊ TRÍ X
                this.x = nextX;

                // [QUAN TRỌNG] Hỗ trợ leo dốc mượt
                // Nếu đang leo lên (slope > 0), nhích Y lên một chút để xe không bị chìm vào đất
                // rồi để hàm update() tự cân bằng lại.
                // TUYỆT ĐỐI KHÔNG GÁN this.y = currentMap.groundY VÀO ĐÂY NỮA
                if (currentY - nextY > 0) { 
                    this.y = nextY - 14; 
                }

                SoundManager.playMove();
                
                if (!this.isAI) {
                    this.moveEnergy -= 1; 
                }
                
                this.checkSupplyPickup(); 
            }
                    
            adjustAngle(d) { if (this.isParachuting) return; this.angle = Math.max(10, Math.min(170, this.angle + d)); }
            
            takeDamage(dmg) { 
                if (this.isShielded && dmg > 0) {
                    this.isShielded = false;
                    showFloatingText("ĐỠ ĐÒN!", this.x, this.y - 80, '#00ffff'); 
                    createExplosion(this.x, this.y, 15, 'smoke');
                    return; 
                }

                // [AN TOÀN]: Nếu dmg bị NaN thì coi như bằng 0
                if (isNaN(dmg) || dmg < 0) dmg = 0;

                if (Math.abs(this.scale) > 1.0) dmg = Math.floor(dmg * 0.8); // Giảm damage khi khổng lồ
                
                this.hp -= dmg; 
                this.hitTimer = 20; 

                if (dmg > 0) {
                    showFloatingText(`-${dmg}`, this.x, this.y - 60, '#ff5252');
                }
            }

            checkSupplyPickup() {
                // Cho phép cả người và máy (nếu sau này có AI) đều nhặt được
                // Logic cũ: if (this.isAI) return; -> XÓA DÒNG NÀY ĐI

                for (let i = supplyDrops.length - 1; i >= 0; i--) {
                    let s = supplyDrops[i];
                    // Kiểm tra khoảng cách va chạm (dùng Math.abs để an toàn)
                    if (!s.isFalling && Math.abs(this.x - s.x) < 30) {
                        createExplosion(s.x, s.y, 15, 'spark');
                        
                        // Xác định tên người nhặt để hiện chat
                        let pickerName = (this === player) ? "P1" : "P2";

                        if (s.type === 'HEAL') { 
                            this.hp = Math.min(this.maxHp, this.hp + s.val); 
                            showFloatingText(`+${s.val} HP`, this.x, this.y - 60, '#00e676'); 
                            addChatLog(pickerName, "Đã hồi máu!");
                        }
                        else if (s.type === 'DAMAGE') { 
                            this.damageBuff = true; 
                            showFloatingText("SÁT THƯƠNG x2!", this.x, this.y - 60, '#ff3d00'); 
                            addChatLog(pickerName, "Nhặt đạn cường hoá!");
                        }
                        else if (s.type === 'GIANT') { 
                            // [FIX QUAN TRỌNG] Giữ nguyên hướng quay mặt của xe
                            // Nếu đang quay phải (scale > 0) -> 1.5
                            // Nếu đang quay trái (scale < 0) -> -1.5
                            let newScale = (this.scale > 0) ? 1.5 : -1.5;
                            this.scale = newScale; 
                            
                            this.maxHp += 50; 
                            this.hp += 50; 
                            showFloatingText("KHỔNG LỒ HOÁ!", this.x, this.y - 80, '#d500f9'); 
                            addChatLog(pickerName, "Biến thành khổng lồ!");
                        }
                        else if (s.type === 'EXTRA_TURN') { 
                            this.extraShot = true; 
                            showFloatingText("+1 LƯỢT BẮN", this.x, this.y - 60, '#2979ff'); 
                            addChatLog(pickerName, "Thêm lượt bắn!");
                        }
                        
                        // Xóa thính sau khi ăn
                        supplyDrops.splice(i, 1);
                    }
                }
            }
            updateParachute() {
                // [FIX] Luôn lấy mặt đất từ map hiện tại để tránh lỗi khi đổi map
                const landingY = currentMap.groundY - 14; 

                if (this.y < landingY) { 
                    this.y += 2.5; 
                    this.x += Math.sin(Date.now() / 200) * 0.8; 
                    
                    // Giới hạn không cho bay ra khỏi map
                    this.x = Math.max(currentMap.minX, Math.min(currentMap.maxX, this.x)); 
                    
                    return false; // Vẫn đang rơi
                } 
                else { 
                    // Đã chạm đất
                    if (this.isParachuting) { 
                        this.y = landingY; // Căn chỉnh lại cho khớp mặt đất
                        this.isParachuting = false; // [QUAN TRỌNG] Cắt dù
                        SoundManager.playLand(); 
                        return true; 
                    } 
                    return true; 
                } 
            }
            // --- SỬA TRONG CLASS BaseTank ---
            draw(ctx) {
                ctx.save(); 
                ctx.translate(this.x, this.y); 
                
                // [FIX QUAN TRỌNG]: Mở lại scale để Buff Khổng Lồ hoạt động
                // Dùng this.scale cho X để lật hướng (nếu âm) và tăng kích thước (nếu > 1)
                // Dùng Math.abs(this.scale) cho Y để xe không bị lộn ngược đầu xuống đất
                ctx.scale(this.scale, Math.abs(this.scale));
                
                // Xoay thân xe theo địa hình
                ctx.rotate(this.bodyAngle); 

                // Hiệu ứng nhấp nháy khi bị bắn
                if (this.hitTimer > 0) { 
                    this.hitTimer--; 
                    ctx.shadowBlur = 25; 
                    ctx.shadowColor = (this.hitTimer % 6 < 3) ? '#ff3d00' : '#ffffff'; 
                }
                
                // Hiệu ứng Buff Damage
                if (this.damageBuff) { 
                    ctx.shadowBlur = 15; 
                    ctx.shadowColor = '#ff3d00'; 
                }
                
                this.drawTracks(ctx); 
                this.drawBody(ctx); 
                this.drawTurret(ctx); 
                
                if (this.isParachuting) this.drawParachute(ctx);
                
                ctx.restore(); 
                
                // Thanh máu vẽ riêng (không xoay theo xe) để dễ nhìn
                if (!this.isParachuting) this.drawHPBar(ctx);
            }
            drawTracks(ctx) {
                ctx.fillStyle = '#222'; ctx.beginPath(); ctx.moveTo(-24, 14); ctx.lineTo(24, 14); ctx.lineTo(28, 4); ctx.lineTo(-28, 4); ctx.fill();
                ctx.fillStyle = '#444'; for (let i = 0; i < 6; i++) { ctx.beginPath(); ctx.arc(-20 + (i * 8), 8.5, 3.5, 0, Math.PI * 2); ctx.fill(); }
                ctx.strokeStyle = '#111'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-28, 4); ctx.lineTo(28, 4); ctx.stroke();
            }
            drawBody(ctx) { ctx.fillStyle = this.color; ctx.fillRect(-22, -4, 44, 8); ctx.strokeStyle = '#000'; ctx.lineWidth = 3; ctx.strokeRect(-22, -4, 44, 8); }
           // --- SỬA TRONG CLASS BaseTank ---
            drawTurret(ctx) { 
                ctx.save(); 
                // [FIX GÓC NÒNG]: Nếu xe đang bị lật (Player 2), góc vẽ phải đối xứng lại
                let drawAngle = (this.scale < 0) ? (180 - this.angle) : this.angle;
                
                ctx.beginPath(); 
                ctx.arc(0, -4, 14, Math.PI, 0); 
                ctx.fillStyle = this.color; 
                ctx.fill(); 
                ctx.strokeStyle = '#000'; 
                ctx.lineWidth = 3; 
                ctx.stroke(); 
                
                ctx.restore(); // (Lưu ý: BaseTank gốc vẽ turret đơn giản, các tank con sẽ override lại)
            }
            drawParachute(ctx) {
                ctx.save(); let sway = Math.sin(Date.now() / 250) * 0.15; ctx.rotate(sway); const anchorX = 0; const anchorY = -22; const canopyY = -70; const canopyW = 40;
                ctx.beginPath(); ctx.moveTo(anchorX, anchorY); ctx.lineTo(-canopyW, canopyY); ctx.moveTo(anchorX, anchorY); ctx.lineTo(0, canopyY - 5); ctx.moveTo(anchorX, anchorY); ctx.lineTo(canopyW, canopyY); ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5; ctx.stroke();
                ctx.beginPath(); ctx.arc(0, canopyY, canopyW, Math.PI, 0); ctx.fillStyle = this.color || '#fff'; ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#fff'; ctx.stroke(); 
                ctx.beginPath(); ctx.moveTo(0, canopyY); ctx.lineTo(0, canopyY - 35); ctx.lineWidth = 1; ctx.stroke(); ctx.restore();
            }
            drawHPBar(ctx) {
                // [FIX LỖI] Dùng Math.abs để luôn lấy giá trị dương
                // Dù scale là -1 hay 1 thì hpYOffset vẫn luôn là dương để thanh máu nằm trên đầu
                const hpYOffset = 45 * Math.abs(this.scale); 
                
                const hpX = this.x - 25; 
                const hpY = this.y - hpYOffset; 
                
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; 
                ctx.fillRect(hpX, hpY, 50, 6); 
                
                const hpP = Math.max(0, this.hp / this.maxHp); 
                ctx.fillStyle = hpP < 0.3 ? '#ff5252' : '#00e676'; 
                ctx.fillRect(hpX, hpY, 50 * hpP, 6);

                // Hiện tên Player 1 / Player 2 ở trên số máu
                // Dùng màu trắng và đậm để dễ nhìn
                ctx.fillStyle = 'black'; 
                ctx.font = 'bold 10px Arial';
                ctx.shadowColor = 'black';
                // ctx.shadowBlur = 2;
                // Vẽ cao hơn thanh máu một chút (hpY - 12)
                ctx.fillText(this.name, this.x - 17, hpY - 12);
                
                ctx.save(); 
                ctx.fillStyle = '#ff0000'; // Màu đỏ rực
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center'; 
                ctx.shadowBlur = 0;
                ctx.fillText(`${Math.floor(this.hp)}/${Math.floor(this.maxHp)}`, this.x, hpY - 2);
                ctx.restore();

                if (this.damageBuff) { ctx.fillStyle = '#ff3d00'; ctx.font = 'bold 12px Arial'; ctx.fillText('DMG x2', this.x + 35, hpY); }
                if (this.extraShot) { ctx.fillStyle = '#2979ff'; ctx.font = 'bold 12px Arial'; ctx.fillText('+1 TURN', this.x - 35, hpY); }
            }

            fireNormal(power, windVal) { return []; }
            fireSkill1(power, windVal) { return []; }
            fireSkill2(power, windVal) { return []; }
        }

        // --- 3. ARTILLERY GUN TANK ---
        class ArtilleryGunTank extends BaseTank {
            drawBody(ctx) {
                super.drawBody(ctx); ctx.fillStyle = this.color; ctx.fillRect(-22, -4, 44, 12); ctx.strokeStyle = '#00000091'; ctx.strokeRect(-22, -4, 44, 12); ctx.beginPath(); ctx.arc(0, -4, 16, Math.PI, 0); ctx.fill(); ctx.stroke();
            }
            // --- TÌM VÀ THAY THẾ TRONG CLASS: ArtilleryGunTank ---
            drawTurret(ctx) {
                ctx.save(); // <--- Đã mở save tại đây
                ctx.translate(0, -10);
                
                // [FIX GÓC]
                let drawAngle = (this.scale < 0) ? (180 - this.angle) : this.angle;
                ctx.rotate(-drawAngle * Math.PI / 180);

                // Kiểm tra lượt để hiển thị hiệu ứng
                const isMyTurn = (this === player && turn === 'PLAYER1') || (this === player2 && turn === 'PLAYER2');
                
                // 1. Hiệu ứng thân nòng
                if (isMyTurn && activeSkill === 1) { 
                    const blink = Math.floor(Date.now() / 100) % 2 === 0; 
                    ctx.fillStyle = blink ? '#ff1744' : '#b71c1c'; 
                    ctx.shadowBlur = 15; 
                    ctx.shadowColor = '#ff1744'; 
                } else { 
                    ctx.fillStyle = '#FFD700'; 
                    ctx.shadowBlur = 0; 
                }
                
                ctx.fillRect(0, -6, 14, 12); 

                // 2. Hiệu ứng đầu nòng
                if (isMyTurn && activeSkill === 1) { 
                    let grad = ctx.createLinearGradient(14, -4, 44, -4); 
                    grad.addColorStop(0, '#ff5252'); 
                    grad.addColorStop(1, '#d50000'); 
                    ctx.fillStyle = grad; 
                } else { 
                    let grad = ctx.createLinearGradient(14, -4, 44, -4); 
                    grad.addColorStop(0, '#ccc'); 
                    grad.addColorStop(1, '#999'); 
                    ctx.fillStyle = grad; 
                }
                
                ctx.fillRect(14, -4, 30, 8); 
                ctx.strokeRect(14, -4, 30, 8); 
                
                ctx.restore(); // <--- QUAN TRỌNG: Phải có dòng này để kết thúc save
            }
            getAimSettings(currentSkillId) {
                if (currentSkillId === 2) {
                    return {
                        steps: 300, 
                        isSolid: true, 
                        colorStart: '#ffeb3b', 
                        colorEnd: 'rgba(255, 0, 0, 0)' 
                    };
                }
                return super.getAimSettings(currentSkillId);
            }

            createMuzzleFlash(offsetAngle) { 
                SoundManager.playShoot(); 
                // [MỚI] Lấy toạ độ nòng súng chuẩn
                const params = this.getShootingParams();
                // Hiệu ứng nổ ngay tại đầu nòng
                createExplosion(this.x + params.x, this.y + params.y, 10, 'smoke'); 
            }

           fireNormal(power, windVal) { 
                this.createMuzzleFlash(0); 
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                
                // [MACRO] Bắn thường: 1 viên, 35 Dame gốc (+0-5 random) -> Tổng ~35-40
                return [new ArtilleryBullet(this.x + params.x, this.y + params.y, realAngle, power, windVal, 35)]; 
            }

            fireSkill1(power, windVal) { 
                this.createMuzzleFlash(0); 
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                
                // [MACRO] Skill 1: 3 viên, 26 Dame gốc/viên -> Tổng ~78-93
                return [
                    new ArtilleryBullet(this.x + params.x, this.y + params.y, realAngle, power, windVal, 26), 
                    new ArtilleryBullet(this.x + params.x, this.y + params.y, realAngle - 5, power, windVal, 26), 
                    new ArtilleryBullet(this.x + params.x, this.y + params.y, realAngle + 5, power, windVal, 26)
                ]; 
            }

            fireSkill2(power, windVal) { 
                this.createMuzzleFlash(0); 
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                
                // [NERF] Giảm từ 90 -> 75. 
                // Vì có Aim Guide dễ trúng, dame chỉ nên ở mức khá.
                return [new ArtilleryBullet(this.x + params.x, this.y + params.y, realAngle, power, windVal, 75)]; 
            }
        }

        // --- 4. MachineGunTank ---
        class MachineGunTank extends BaseTank {
            getPhysics() { return { gravity: 0.12, powerMulti: 1.0 }; }
            
            adjustAngle(d) { 
                if (this.isParachuting) return; 
                this.angle = Math.max(0, Math.min(180, this.angle + d)); 
            }
            
            getAimSettings(currentSkillId) {
                if (currentSkillId === 2) {
                    return {
                        steps: 300, 
                        isSolid: true,
                        colorStart: '#ff9800', 
                        colorEnd: 'rgba(255, 255, 255, 0)'
                    };
                }
                return super.getAimSettings(currentSkillId);
            }
            
            drawBody(ctx) { super.drawBody(ctx); ctx.fillStyle = this.color; ctx.fillRect(-22, -4, 44, 12); ctx.strokeStyle = '#000'; ctx.lineWidth = 3; ctx.strokeRect(-22, -4, 44, 12); ctx.beginPath(); ctx.arc(0, -4, 16, Math.PI, 0); ctx.fill(); ctx.stroke(); }
            
            drawTurret(ctx) {
                ctx.save(); ctx.translate(0, -10);
                // [FIX GÓC]
                let drawAngle = (this.scale < 0) ? (180 - this.angle) : this.angle;
                ctx.rotate(-drawAngle * Math.PI / 180);
                ctx.lineWidth = 3; ctx.strokeStyle = '#000';
                ctx.fillStyle = this.color; ctx.fillRect(-2, -8, 18, 16); ctx.strokeRect(-2, -8, 18, 16);
                ctx.fillStyle = '#333'; ctx.fillRect(16, -6, 32, 5); ctx.strokeRect(16, -6, 32, 5); ctx.fillRect(16, 1, 32, 5); ctx.strokeRect(16, 1, 32, 5);
                ctx.fillStyle = '#000'; ctx.fillRect(45, -7, 6, 7); ctx.fillRect(45, 0, 6, 7);
                // [FIX LỖI HIỂN THỊ SKILL]: Kiểm tra đúng lượt người chơi
                const isMyTurn = (this === player && turn === 'PLAYER1') || (this === player2 && turn === 'PLAYER2');
                if (isMyTurn && activeSkill === 1) { 
                    ctx.shadowBlur = 10; 
                    ctx.shadowColor = '#ff0000'; 
                    ctx.strokeStyle = '#ff0000'; 
                    ctx.strokeRect(16, -6, 32, 5); 
                    ctx.strokeRect(16, 1, 32, 5); 
                }
                ctx.restore();
            }
            
            calculateTrajectory(power, windVal, stepsLimit = 20) {
                // [FIX]
                const params = this.getShootingParams();
                const phys = this.getPhysics(); 
                let windResist = 0.4; 
                
                let sx = params.x;
                let sy = params.y;
                let speed = power * SPEED_CONSTANT * phys.powerMulti;
                
                let vx = Math.cos(params.rad) * speed;
                let vy = -Math.sin(params.rad) * speed;

                let points = [{x: sx, y: sy}];
                let curX = sx, curY = sy;
                let steps = (typeof stepsLimit === 'number') ? stepsLimit : (stepsLimit ? 300 : 20);

                for (let i = 0; i < steps; i++) {
                    vx += windVal * WIND_FACTOR * windResist; 
                    vy += phys.gravity;
                    curX += vx;
                    curY += vy;
                    points.push({x: curX, y: curY});
                    if (steps > 50 && currentMap.isGroundCollision(this.x + curX, this.y + curY)) break;
                }

                return { type: 'curve', points: points };
            }

            createMuzzleFlash(offsetAngle) { 
                const params = this.getShootingParams();
                // Hiệu ứng nổ tại nòng
                createExplosion(this.x + params.x, this.y + params.y, 4, 'spark'); 
            }
            
            // --- TÌM CLASS: MachineGunTank ---

            fireNormal(power, windVal) { 
                this.createMuzzleFlash(0); 
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                let bullets = []; 
                // [MACRO] Bắn thường: 3 viên, 11 Dame gốc -> Tổng ~33-48
                for (let i = 0; i < 3; i++) { 
                    let angleDev = (Math.random() - 0.5) * 6; 
                    let b = new MachineGunBullet(this.x + params.x, this.y + params.y, realAngle + angleDev, power, windVal, i); 
                    b.damage = 11; 
                    bullets.push(b); 
                } 
                return bullets; 
            }

            fireSkill1(power, windVal) { 
                this.createMuzzleFlash(0); 
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                let bullets = []; 
                // [MACRO] Skill 1: 6 viên, 12 Dame gốc -> Tổng ~72-102
                for (let i = 0; i < 6; i++) { 
                    let angleDev = (Math.random() - 0.5) * 8; 
                    let b = new MachineGunBullet(this.x + params.x, this.y + params.y, realAngle + angleDev, power, windVal, i); 
                    b.damage = 12; 
                    bullets.push(b); 
                } 
                return bullets; 
            }

            fireSkill2(power, windVal) { 
                this.createMuzzleFlash(0); 
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                let bullets = []; 
                for (let i = 0; i < 3; i++) { 
                    let angleDev = 0; 
                    let b = new MachineGunBullet(this.x + params.x, this.y + params.y, realAngle + angleDev, power, windVal, i); 
                    // [NERF] Giảm từ 30 -> 24. Tổng 3 viên = 72.
                    b.damage = 24; 
                    bullets.push(b); 
                } 
                return bullets; 
            }
        }

        // --- Laser Tank ---
        class LaserTank extends BaseTank {
            onTurnEnd() {
                super.onTurnEnd(); 
                for (let i = bullets.length - 1; i >= 0; i--) {
                    if (bullets[i].type === 'SATELLITE') {
                        bullets.splice(i, 1);
                    }
                }
            }

            getAimSettings(currentSkillId) {
                if (currentSkillId === 2) {
                    return {
                        steps: 2, 
                        isSolid: true,
                        colorStart: this.color,
                        colorEnd: 'rgba(255,255,255,0)'
                    };
                }
                return super.getAimSettings(currentSkillId);
            }

            drawBody(ctx) {
                this.drawTracks(ctx); ctx.fillStyle = '#263238'; ctx.fillRect(-24, -6, 48, 14); ctx.strokeStyle = '#00e5ff'; ctx.lineWidth = 2; ctx.strokeRect(-24, -6, 48, 14);
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(-15, -6); ctx.lineTo(-5, 0); ctx.lineTo(-15, 6); ctx.fill();
            }
            drawTurret(ctx) {
                ctx.save();
                ctx.translate(0, -10);
                // [FIX GÓC]
                let drawAngle = (this.scale < 0) ? (180 - this.angle) : this.angle;
                ctx.rotate(-drawAngle * Math.PI / 180);
                if (this === player && activeSkill) { ctx.shadowBlur = 10; ctx.shadowColor = (activeSkill === 2) ? '#d500f9' : '#00e5ff'; }
                ctx.fillStyle = '#37474f'; ctx.fillRect(-10, -10, 20, 20); ctx.strokeStyle = '#00e5ff'; ctx.strokeRect(-10, -10, 20, 20);
                ctx.fillStyle = '#222'; ctx.fillRect(10, -4, 35, 8); ctx.fillStyle = this.color; ctx.fillRect(10, -9, 30, 3); ctx.fillRect(10, 6, 30, 3);
                ctx.fillStyle = '#e0f7fa'; ctx.fillRect(10, -1, 35, 2); ctx.restore();
            }
            calculateTrajectory(power, windVal, stepsLimit = 20) {
                let length = stepsLimit * 8; 

                // [FIX]
                const params = this.getShootingParams();
                
                let sx = params.x;
                let sy = params.y;

                let ex = sx + Math.cos(params.rad) * length;
                let ey = sy - Math.sin(params.rad) * length;

                return { type: 'line', points: [{x: sx, y: sy}, {x: ex, y: ey}] };
            }
            createMuzzleFlash(offsetAngle) { 
                SoundManager.playShoot(); 
                const params = this.getShootingParams();
                createExplosion(this.x + params.x, this.y + params.y, 15, 'spark'); 
            }

            fireNormal(power, windVal) { 
                this.createMuzzleFlash(0); 
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                let b = new LaserBullet(this.x + params.x, this.y + params.y, realAngle, power, windVal, 'NORMAL');
                // [MACRO] Bắn thường: 1 tia, 40 Dame gốc -> Tổng ~40-45
                b.damage = 40; 
                return [b]; 
            }

            fireSkill1(power, windVal) { 
                this.createMuzzleFlash(0); 
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                return [new LaserBullet(this.x + params.x, this.y + params.y, realAngle, power, windVal, 'SPLIT_PARENT')]; 
            }
            fireSkill2(power, windVal) { 
                this.createMuzzleFlash(0); 
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                return [new LaserBullet(this.x + params.x, this.y + params.y, realAngle, power, windVal, 'TRIGGER')]; 
            }
            deploySatellite() {
                for (let i = bullets.length - 1; i >= 0; i--) { if (bullets[i].type === 'SATELLITE') bullets.splice(i, 1); }
                let satX = this.x + 60; let satY = this.y - 120; bullets.push(new LaserBullet(satX, satY, 0, 0, 0, 'SATELLITE'));
                SoundManager.playShoot(); createExplosion(satX, satY, 10, 'spark');
            }
        }

        class BoomerangTank extends BaseTank {
           constructor(x, color, name, isAI) {
                super(x, color, name, isAI);
            }

            getAimSettings(currentSkillId) {
                if (currentSkillId === 2) {
                    return {
                        steps: 300,           
                        isSolid: true,
                        colorStart: '#76ff03', 
                        colorEnd: '#ccff90'    
                    };
                }
                return super.getAimSettings(currentSkillId);
            }

            // [FIX 1] Sửa lỗi bấm nút Lên/Xuống bị ngược chiều
            adjustAngle(d) {
                if (this.isParachuting) return;
                
                // Nếu xe đang quay sang trái (scale = -1), đảo ngược hướng điều chỉnh
                let adjustment = (this.scale < 0) ? -d : d;
                
                this.angle = Math.max(30, Math.min(150, this.angle + adjustment));
            }

            drawBody(ctx) {
                super.drawBody(ctx);
                ctx.fillStyle = '#33691e'; ctx.fillRect(-22, -4, 44, 12); ctx.strokeStyle = '#1b5e20'; ctx.strokeRect(-22, -4, 44, 12);
                ctx.beginPath(); ctx.arc(0, -4, 16, Math.PI, 0); ctx.fillStyle = this.color; ctx.fill(); ctx.stroke();
            }
            // [FIX 2] Sửa triệt để lỗi nòng pháo quay ngược
            // --- TÌM ĐOẠN NÀY TRONG FILE CỦA BẠN (Class BoomerangTank) ---

            drawTurret(ctx) {
                ctx.save(); 
                ctx.translate(0, -10); // Dời tâm về khớp nối

                // [ĐÃ SỬA] XÓA DÒNG ctx.scale(this.scale, 1); ĐI
                // Vì góc angle của Player 2 là 135 độ đã tự động lo việc hướng nòng súng sang trái rồi.
                // Việc scale -1 ở đây làm nòng bị lộn ngược lại một lần nữa không cần thiết.

                // Giữ nguyên dòng xoay góc
                // [FIX GÓC]
                let drawAngle = (this.scale < 0) ? (180 - this.angle) : this.angle;
                ctx.rotate(-drawAngle * Math.PI / 180);

                // Hiệu ứng phát sáng khi dùng skill
                if (this === player && activeSkill === 2) { ctx.shadowBlur = 15; ctx.shadowColor = '#76ff03'; }
                else if (this === player2 && activeSkill === 2) { ctx.shadowBlur = 15; ctx.shadowColor = '#76ff03'; }

                // Vẽ nòng pháo (Code vẽ giữ nguyên)
                ctx.fillStyle = '#558b2f'; ctx.fillRect(0, -6, 10, 12); 
                ctx.fillStyle = '#76ff03'; 
                ctx.fillRect(10, -8, 28, 4); ctx.strokeRect(10, -8, 28, 4);
                ctx.fillRect(10, 4, 28, 4); ctx.strokeRect(10, 4, 28, 4);
                
                ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(25, -6); ctx.lineTo(25, 6); ctx.closePath(); ctx.fillStyle = '#ccff90'; ctx.fill();
                
                ctx.restore();
            }

            calculateTrajectory(power, windVal, stepsLimit = 20) {
                // [FIX]
                const params = this.getShootingParams();

                let sx = params.x;
                let sy = params.y;
                
                let speed = power * SPEED_CONSTANT; 
                let vx = Math.cos(params.rad) * speed;
                let vy = -Math.sin(params.rad) * speed;

                let points = [{x: sx, y: sy}];
                let curX = sx, curY = sy;
                
                let steps = (typeof stepsLimit === 'number') ? stepsLimit : 20;

                let currentGravity = GRAVITY;
                let windResist = 0.3; 
                let pendingAccelX = 0;
                let turnStartFrame = 0;

                // Logic Boomerang giữ nguyên nhưng dùng params.rad thay vì this.angle trực tiếp để check điều kiện
                // Chuyển params.rad về độ để check logic cũ
                let effectiveAngleDeg = params.rad * 180 / Math.PI;
                // Chuẩn hóa về 0-360 dương để so sánh
                while (effectiveAngleDeg < 0) effectiveAngleDeg += 360;

                // Logic cũ: if (this.angle > 70 && this.angle < 110)
                // Logic mới: Dùng góc thực tế
                // Tuy nhiên để đơn giản và giữ cảm giác chơi cũ, ta có thể vẫn dùng this.angle cho logic check skill,
                // nhưng dùng vx, vy mới cho đường đạn.
                
                if (this.angle > 70 && this.angle < 110) {
                    currentGravity = GRAVITY * 0.35; 
                    pendingAccelX = 0;
                } else {
                    vx *= 1.3; 
                    vy *= 1.3;
                    turnStartFrame = 55; 
                    let hookStrength = 0.25; 
                    if (this.angle < 90) pendingAccelX = -hookStrength; 
                    else pendingAccelX = hookStrength;
                }

                for (let i = 0; i < steps; i++) {
                    vx += windVal * WIND_FACTOR * windResist;
                    if (pendingAccelX !== 0 && i > turnStartFrame) { vx += pendingAccelX; }
                    vy += currentGravity; 
                    curX += vx; curY += vy;
                    points.push({x: curX, y: curY});
                    if (steps > 50 && currentMap.isGroundCollision(this.x + curX, this.y + curY)) break;
                }

                return { type: 'curve', points: points };
            }

           createMuzzleFlash(offsetAngle) { 
                SoundManager.playShoot(); 
                const params = this.getShootingParams();
                createExplosion(this.x + params.x, this.y + params.y, 10, 'smoke'); 
            }

            // --- TÌM CLASS: BoomerangTank ---

            fireNormal(power, windVal) { 
                this.createMuzzleFlash(0); 
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                // [MACRO] Bắn thường: 1 viên, 45 Dame gốc -> Tổng ~45-50 (Thưởng kỹ năng)
                return [new BoomerangBullet(this.x + params.x, this.y + params.y, realAngle, power, windVal, 45)]; 
            }

            fireSkill1(power, windVal) { 
                this.createMuzzleFlash(0); 
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                
                let bullets = []; 
                let offsets = [-4, 0, 4]; 
                offsets.forEach(off => { 
                    // [MACRO] Skill 1: 3 viên tỏa, 30 Dame/viên -> Trúng 1=30, Trúng hết=90+
                    let dmg = 30; 
                    bullets.push(new BoomerangBullet(this.x + params.x, this.y + params.y, realAngle + off, power, windVal, dmg)); 
                }); 
                return bullets; 
            }

            fireSkill2(power, windVal) { 
                this.createMuzzleFlash(0); 
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                
                // [NERF] Base 35. Trong Bullet logic nhân đôi sẽ thành 70.
                // Skill này có Aim Guide cong rất bá đạo, cần giảm dame để không quá lỗi.
                let baseDmg = 35; 
                return [new BoomerangBullet(this.x + params.x, this.y + params.y, realAngle, power, windVal, baseDmg, true)]; 
            }
        }

        class CommandoTank extends BaseTank {
            constructor(x, color, name, isAI) {
                super(x, '#607d8b', 'Đặc Nhiệm', isAI); 
                this.radarAngle = 0;
            }

            drawBody(ctx) {
                this.drawTracks(ctx); super.drawBody(ctx);  
                ctx.save(); ctx.translate(-18, -4); 
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -22); ctx.lineWidth = 2; ctx.strokeStyle = '#37474f'; ctx.stroke();
                if (Math.floor(Date.now() / 200) % 2 === 0) {
                    ctx.fillStyle = '#ff1744'; ctx.shadowBlur = 5; ctx.shadowColor = 'red';
                    ctx.beginPath(); ctx.arc(0, -22, 2.5, 0, Math.PI*2); ctx.fill();
                }
                ctx.restore();
            }

            drawTurret(ctx) {
                ctx.save(); ctx.translate(0, -10); 
                this.radarAngle += 0.05;
                ctx.save(); ctx.translate(0, -8); ctx.rotate(Math.sin(this.radarAngle) * 0.5); 
                ctx.fillStyle = '#90a4ae'; ctx.beginPath(); ctx.arc(0, -8, 12, Math.PI, 0); ctx.fill(); ctx.stroke(); 
                ctx.fillStyle = '#eceff1'; ctx.beginPath(); ctx.arc(0, -8, 4, 0, Math.PI*2); ctx.fill(); ctx.restore();

                // [FIX GÓC]
                let drawAngle = (this.scale < 0) ? (180 - this.angle) : this.angle;
                ctx.rotate(-drawAngle * Math.PI / 180);
                ctx.fillStyle = '#37474f'; ctx.fillRect(0, -4, 25, 8); ctx.strokeStyle = '#000'; ctx.strokeRect(0, -4, 25, 8);
                ctx.fillStyle = '#546e7a'; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                if (activeSkill) { ctx.shadowBlur = 10; ctx.shadowColor = (activeSkill===1) ? '#ff1744' : '#ffea00'; }
                ctx.restore();
            }

            getAimSettings(currentSkillId) {
                if (currentSkillId === 2) { 
                    return { steps: 300, isSolid: true, colorStart: '#ffea00', colorEnd: 'rgba(255, 61, 0, 0)' };
                }
                return super.getAimSettings(currentSkillId);
            }

            calculateTrajectory(power, windVal, stepsLimit = 20) {
                // [FIX]
                const params = this.getShootingParams();
                
                let sx = params.x; 
                let sy = params.y; 
                
                let speed = power * SPEED_CONSTANT;
                let vx = Math.cos(params.rad) * speed;
                let vy = -Math.sin(params.rad) * speed;

                let points = [{x: sx, y: sy}];
                let curX = sx, curY = sy;
                let steps = (typeof stepsLimit === 'number') ? stepsLimit : 20;
                let windResist = 0.8; 

                for (let i = 0; i < steps; i++) {
                    vx += windVal * WIND_FACTOR * windResist; 
                    vy += GRAVITY;
                    curX += vx; curY += vy;
                    points.push({x: curX, y: curY});
                    if (steps > 50 && currentMap.isGroundCollision(this.x + curX, this.y + curY)) break;
                }
                return { type: 'curve', points: points };
            }

            createUplinkEffect() {
                for(let i=0; i<20; i++) {
                    particles.push(new Particle(this.x + (Math.random()-0.5)*10, this.y - 20, 'spark', { vx: 0, vy: -5 - Math.random()*10, life: 0.5, size: 2, color: '#ff1744' }));
                }
                showFloatingText("GỬI TÍN HIỆU...", this.x, this.y - 80, '#ff1744');
            }

            createMuzzleFlash(offsetAngle) {
                SoundManager.playShoot();
                const params = this.getShootingParams();
                createExplosion(this.x + params.x, this.y + params.y, 5, 'smoke');
            }


           fireNormal(power, windVal) { 
                this.createMuzzleFlash(0); 
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                return [new SignalFlareBullet(this.x + params.x, this.y + params.y, realAngle, power, windVal, 'NORMAL')]; 
            }

            fireSkill1(power, windVal) { 
                this.createUplinkEffect(); 
                this.createMuzzleFlash(0);
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                return [new SignalFlareBullet(this.x + params.x, this.y + params.y, realAngle, power, windVal, 'CARPET')];
            }
            
            fireSkill2(power, windVal) { 
                this.createMuzzleFlash(0);
                const params = this.getShootingParams();
                let realAngle = params.rad * 180 / Math.PI;
                return [new SignalFlareBullet(this.x + params.x, this.y + params.y, realAngle, power, windVal, 'NUKE')];
            }
        }
                
        // ==========================================
        // === TANK ROSTER & MENU CONFIG ===
        // ==========================================
        const TANK_ROSTER = [
            { id: 'artillery', name: 'PHÁO KÍCH', desc: 'Sát thương cao, đạn cầu vồng cổ điển.', className: ArtilleryGunTank, color: '#e53935', skill1Name: '3 Đạn (< 80% HP)', skill2Name: 'Lộ Sight (< 60% HP)' },
            { id: 'machinegun', name: 'SÚNG MÁY', desc: 'Bắn liên thanh, đạn bay nhanh.', className: MachineGunTank, color: '#FFD700', skill1Name: 'Sấy 6 Viên (< 80% HP)', skill2Name: 'Lộ Sight (< 60% HP)' },
            { id: 'laser', name: 'XE LASER', desc: 'Đạn chậm, tách hạt nổ trên không.', className: LaserTank, color: '#d500f9', skill1Name: 'Mưa Laser (Tách khi rơi)', skill2Name: 'Tia Hủy Diệt (x2 DMG)' },
            { 
                id: 'boomerang', 
                name: 'BOOMERANG', 
                desc: 'Đạn bay quỹ đạo móc câu. Kỹ năng cao.', 
                className: BoomerangTank, 
                color: '#76ff03', 
                skill1Name: 'Tam Giác Mạch (3 Tia)', 
                skill2Name: 'Móc Tử Thần (x2 DMG + Aim)' 
            },
            { 
                id: 'commando', 
                name: 'ĐẶC NHIỆM', 
                desc: 'Bắn pháo hiệu chỉ điểm máy bay ném bom.', 
                className: CommandoTank, 
                color: '#607d8b', 
                skill1Name: 'Rải Thảm (5 Quả)', 
                skill2Name: 'Bom Chiến Thuật (120 DMG)' 
            }
        ];

        // let selectedTankIndex = 0;
        let selectedDifficulty = 'EASY';

        function updateTankPreview() {
            const tankInfo = TANK_ROSTER[selectedTankIndex];
            document.getElementById('tank-preview-name').innerText = tankInfo.name;
            document.getElementById('tank-preview-desc').innerText = tankInfo.desc;
        }

        // function changeTank(dir) {
        //     selectedTankIndex += dir;
        //     if (selectedTankIndex < 0) selectedTankIndex = TANK_ROSTER.length - 1;
        //     if (selectedTankIndex >= TANK_ROSTER.length) selectedTankIndex = 0;
        //     updateTankPreview();
        // }

        // --- DANH SÁCH MAP (Mở rộng dễ dàng sau này) ---
        const MAP_ROSTER = [
            { id: 'island', name: 'ĐẢO DỪA', desc: 'Gió biển mạnh, địa hình nhấp nhô.', className: CoconutIslandMap },
            { id: 'bridge', name: 'CẦU SẮT', desc: 'Địa hình phẳng, vực thẳm chết chóc.', className: IronBridgeMap }
        ];
        

        function updateMapPreview() {
            const mapInfo = MAP_ROSTER[selectedMapIndex];
            document.getElementById('map-preview-name').innerText = mapInfo.name;
            document.getElementById('map-preview-desc').innerText = mapInfo.desc;
        }

        function changeMap(dir) {
            selectedMapIndex += dir;
            if (selectedMapIndex < 0) selectedMapIndex = MAP_ROSTER.length - 1;
            if (selectedMapIndex >= MAP_ROSTER.length) selectedMapIndex = 0;
            updateMapPreview();
        }

        // ==========================================
        // === GAME LOGIC & HELPERS ===
        // ==========================================

        function toggleMap(show) { if (show) { mmContainer.classList.add('show'); mmOverlay.classList.add('show'); btnToggleMap.classList.add('active'); drawMinimap(); } else { mmContainer.classList.remove('show'); mmOverlay.classList.remove('show'); btnToggleMap.classList.remove('active'); } }
        btnToggleMap.addEventListener('click', (e) => { e.stopPropagation(); const isShowing = mmContainer.classList.contains('show'); toggleMap(!isShowing); });
        btnCloseMap.addEventListener('click', (e) => { e.stopPropagation(); toggleMap(false); });
        mmOverlay.addEventListener('click', (e) => { e.stopPropagation(); toggleMap(false); });
        btnToggleMap.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); const isShowing = mmContainer.classList.contains('show'); toggleMap(!isShowing); });
        btnCloseMap.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); toggleMap(false); });
        mmOverlay.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); toggleMap(false); });

        function togglePause() {
            if (gameState !== 'PLAYING' && gameState !== 'PAUSED' && gameState !== 'INTRO') return;
            isPaused = !isPaused;
            if (isPaused) { if(gameState === 'INTRO') { pauseMenu.classList.remove('hidden'); btnPauseText.innerText = "TIẾP"; return; } gameState = 'PAUSED'; pauseMenu.classList.remove('hidden'); btnPauseText.innerText = "TIẾP"; SoundManager.stopCharge(); SoundManager.stopWind(); SoundManager.stopBGM(); } 
            else { 
                if(player.isParachuting) { gameState = 'INTRO'; pauseMenu.classList.add('hidden'); btnPauseText.innerText = "DỪNG"; SoundManager.playWind(); return; } 
                gameState = 'PLAYING'; pauseMenu.classList.add('hidden'); btnPauseText.innerText = "DỪNG"; SoundManager.playBGM();
            }
        }
        btnPauseText.addEventListener('click', (e) => { e.stopPropagation(); togglePause(); });
        btnPauseText.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); togglePause(); });

        function drawMinimap() {
            // Chỉ vẽ khi cần thiết (mobile)
            if (window.innerWidth <= 600 && !mmContainer.classList.contains('show')) return;
            
            mmCtx.save(); 
            mmCtx.scale(dpr, dpr); 
            mmCtx.clearRect(0, 0, MINIMAP_WIDTH, MINIMAP_HEIGHT);

            // 1. [QUAN TRỌNG] Gọi Map hiện tại để vẽ nền Mini Map
            // Lưu ý: Ta truyền MAP_SCALE vào để Map tự tính toán thu nhỏ
            currentMap.drawMinimap(mmCtx, MAP_SCALE);

            // 2. Vẽ các vật thể động (Người, Máy, Hòm tiếp tế) đè lên trên
            if (player) drawDot(player.x, player.y, '#00ff00', 4); 
            if (player2 && player2.hp > 0) drawDot(player2.x, player2.y, '#ff3d00', 4);
            supplyDrops.forEach(s => drawDot(s.x, s.y, '#fff', 3));
            
            // 3. Vẽ khung Camera
            mmCtx.strokeStyle = '#fff'; 
            mmCtx.lineWidth = 1; 
            mmCtx.strokeRect(cameraX * MAP_SCALE, cameraY * MAP_SCALE, VIEWPORT_W * MAP_SCALE, SCREEN_H * MAP_SCALE);
            
            mmCtx.restore();
        }
        function drawDot(x, y, color, radius) { mmCtx.beginPath(); mmCtx.arc(x * MAP_SCALE, y * MAP_SCALE, radius, 0, Math.PI * 2); mmCtx.fillStyle = color; mmCtx.fill(); }

        // --- SOUND MANAGER ---
        const SoundManager = {
            ctx: null, osc: null, gainNode: null, 
            init: function() { if (!this.ctx) { const AC = window.AudioContext || window.webkitAudioContext; this.ctx = new AC(); } if (this.ctx.state === 'suspended') this.ctx.resume(); },
            createNoiseBuffer: function() { if (!this.ctx) return null; const bSize = this.ctx.sampleRate * 2; const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate); const data = buf.getChannelData(0); for (let i = 0; i < bSize; i++) data[i] = Math.random() * 2 - 1; return buf; },
            playShoot: function() { if (!this.ctx) return; const t = this.ctx.currentTime; const noise = this.ctx.createBufferSource(); noise.buffer = this.createNoiseBuffer(); const nf = this.ctx.createBiquadFilter(); nf.type = 'lowpass'; nf.frequency.setValueAtTime(1000, t); nf.frequency.exponentialRampToValueAtTime(100, t + 0.2); const ng = this.ctx.createGain(); ng.gain.setValueAtTime(0.5, t); ng.gain.exponentialRampToValueAtTime(0.01, t + 0.2); noise.connect(nf); nf.connect(ng); ng.connect(this.ctx.destination); noise.start(t); noise.stop(t + 0.3); },
            playExplosion: function() { if (!this.ctx) return; const t = this.ctx.currentTime; const noise = this.ctx.createBufferSource(); noise.buffer = this.createNoiseBuffer(); const nf = this.ctx.createBiquadFilter(); nf.type = 'lowpass'; nf.frequency.value = 800; const ng = this.ctx.createGain(); ng.gain.setValueAtTime(1.0, t); ng.gain.exponentialRampToValueAtTime(0.01, t + 0.8); noise.connect(nf); nf.connect(ng); ng.connect(this.ctx.destination); noise.start(t); noise.stop(t + 1); },
            playMove: function() { if (!this.ctx) return; const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(40, t); const g = this.ctx.createGain(); g.gain.setValueAtTime(0.1, t); g.gain.linearRampToValueAtTime(0, t + 0.1); osc.connect(g); g.connect(this.ctx.destination); osc.start(t); osc.stop(t + 0.1); },
            playLand: function() { 
                if (!this.ctx) return; const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); osc.type = 'triangle'; osc.frequency.setValueAtTime(80, t); osc.frequency.exponentialRampToValueAtTime(10, t + 0.2); const g = this.ctx.createGain(); g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.2); osc.connect(g); g.connect(this.ctx.destination); osc.start(t); osc.stop(t + 0.2);
                const noise = this.ctx.createBufferSource(); noise.buffer = this.createNoiseBuffer(); const ng = this.ctx.createGain(); ng.gain.setValueAtTime(0.3, t); ng.gain.exponentialRampToValueAtTime(0.01, t + 0.1); noise.connect(ng); ng.connect(this.ctx.destination); noise.start(t); noise.stop(t + 0.1);
            },
            playWind: function() {}, stopWind: function() {}, playBGM: function() {}, stopBGM: function() {},
            startCharge: function() { if (!this.ctx || this.osc) return; this.osc = this.ctx.createOscillator(); this.osc.type = 'triangle'; this.osc.frequency.setValueAtTime(200, this.ctx.currentTime); this.gainNode = this.ctx.createGain(); this.gainNode.gain.setValueAtTime(0.1, this.ctx.currentTime); this.osc.connect(this.gainNode); this.gainNode.connect(this.ctx.destination); this.osc.start(); },
            updateCharge: function(p) { if (this.osc && this.ctx) this.osc.frequency.setTargetAtTime(200 + (p * 4), this.ctx.currentTime, 0.05); },
            stopCharge: function() { if (this.osc) { this.gainNode.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1); this.osc.stop(this.ctx.currentTime + 0.1); this.osc = null; this.gainNode = null; } }
        };

        class SupplyDrop {
            constructor(x) {
                this.x = x; this.y = -200; this.isFalling = true; this.w = 30; this.h = 24; this.swayAngle = 0; this.intercepted = false; 
                const rand = Math.random();
                if (rand < 0.4) { this.type = 'HEAL'; this.val = (currentModeName === 'DỄ') ? 25 : (currentModeName === 'KHÓ' ? 20 : 15); this.color = '#00e676'; } 
                else if (rand < 0.65) { this.type = 'DAMAGE'; this.val = 2; this.color = '#ff3d00'; } 
                else if (rand < 0.85) { this.type = 'GIANT'; this.val = 1.5; this.color = '#d500f9'; } 
                else { this.type = 'EXTRA_TURN'; this.val = 1; this.color = '#2979ff'; }
            }
           update() {
                if (this.intercepted) return;
                
                // 1. Luôn lấy độ cao đất thực tế ngay tại vị trí hòm thính
                let groundH = currentMap.getHeightAt(this.x);

                // 2. [LOGIC MỚI] Tự động rơi lại nếu đất dưới chân biến mất
                // Nếu đang KHÔNG RƠI (đang đứng yên) mà vị trí Y lại cao hơn đất mới (tức là lơ lửng)
                // Thì kích hoạt lại isFalling. (Trừ đi 5px sai số để tránh rung lắc nhẹ)
                if (!this.isFalling && this.y < groundH - this.h - 5) {
                    this.isFalling = true;
                }

                // 3. Xử lý logic rơi
                if (this.isFalling) {
                    // Tăng tốc độ rơi lên chút (3.0) cho tự nhiên khi sụp hố
                    this.y += 3.0; 
                    
                    // Hiệu ứng lắc lư nhẹ khi rơi
                    this.swayAngle = Math.sin(Date.now() / 300) * 0.15; 
                    
                    // Nếu chưa chạm đất thì cho phép trôi nhẹ theo gió/dao động
                    if (this.y < groundH - this.h - 10) {
                         this.x += Math.sin(Date.now() / 400) * 0.5;
                    }

                    // 4. Kiểm tra va chạm đất
                    if (this.y >= groundH - this.h) { 
                        this.y = groundH - this.h; // Snap chặt vào mặt đất mới
                        this.isFalling = false; 
                        
                        // Chỉ phát tiếng động và hiện chữ nếu đây là lần rơi đầu tiên (từ trên trời xuống)
                        // Để tránh spam âm thanh khi nó chỉ trượt nhẹ xuống hố nhỏ
                        if (this.y < 0) { // Check tạm thời (logic game này drop từ y=-200)
                             SoundManager.playLand(); 
                        }
                        
                        if (activeSupplyDrop === this) { 
                            activeSupplyDrop = null; 
                            showFloatingText("HÀNG ĐÃ ĐẾN!", this.x, this.y - 40, '#fff'); 
                        } 
                    }
                }
            }
            draw() {
                if (this.intercepted) return;
                ctx.save(); ctx.translate(this.x, this.y);
                if (this.isFalling) {
                    ctx.save(); ctx.rotate(this.swayAngle); ctx.strokeStyle = '#eee'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(-15, 0); ctx.lineTo(-25, -40); ctx.moveTo(0, 0); ctx.lineTo(0, -42); ctx.moveTo(15, 0); ctx.lineTo(25, -40); ctx.stroke(); ctx.beginPath(); ctx.arc(0, -40, 30, Math.PI, 0); ctx.fillStyle = this.color; ctx.fill(); ctx.stroke(); ctx.restore();
                }
                ctx.fillStyle = '#333'; ctx.fillRect(-15, 0, 30, 24); ctx.strokeStyle = '#fff'; ctx.strokeRect(-15, 0, 30, 24); ctx.fillStyle = this.color; ctx.fillRect(-10, 5, 20, 14); 
                ctx.fillStyle = '#fff'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center';
                let symbol = "+"; if(this.type === 'DAMAGE') symbol = "DMG"; if(this.type === 'GIANT') symbol = "BIG"; if(this.type === 'EXTRA_TURN') symbol = "1UP";
                ctx.fillText(symbol, 0, 16); ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, type, options = {}) {
                this.x = x; this.y = y; this.type = type;
                this.vx = options.vx || (Math.random() - 0.5) * 5; this.vy = options.vy || (Math.random() - 0.5) * 5;
                this.life = options.life || 1.0; this.decay = options.decay || 0.04; this.size = options.size || (4 + Math.random() * 4);
                this.friction = 0.95; this.gravity = 0.1;
                if (type === 'shockwave') { this.vx = 0; this.vy = 0; this.decay = 0.08; this.size = 1; this.maxSize = 40; }
            }
            update() {
                if (this.type !== 'shockwave') { this.vx *= this.friction; this.vy *= this.friction; this.vy += this.gravity; this.x += this.vx; this.y += this.vy; } else { this.size += 3; }
                this.life -= this.decay;
            }
            draw() {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.life);
                if (this.type === 'smoke') { ctx.fillStyle = '#666'; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); }
                else if (this.type === 'fire') { ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = `rgba(255, ${Math.floor(this.life * 200)}, 0, 1)`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); }
                else if (this.type === 'spark') { ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2); ctx.fill(); }
                else if (this.type === 'shockwave') { ctx.globalCompositeOperation = 'lighter'; ctx.strokeStyle = `rgba(255, 200, 50, ${this.life})`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.stroke(); }
                ctx.restore();
            }
        }

        function startTimer() {
            stopTimer(); 
            timeLeft = turnDuration; // Reset thời gian về 20s hoặc 25s
            updateUI(); // Cập nhật giao diện ngay lập tức để xóa số 0 đỏ
            
            timerInterval = setInterval(() => {
                if (isPaused) return; 
                timeLeft--; 
                updateUI();
                if (timeLeft <= 0) { stopTimer(); handlePlayerTimeout(); }
            }, 1000);
        }
        function stopTimer() { if (timerInterval) { clearInterval(timerInterval); timerInterval = null; } }
        function handlePlayerTimeout() {
            charging = false; SoundManager.stopCharge(); currentPower = 0; keys = {};
            // Thay vì gọi aiMovePhase, ta gọi switchTurn luôn để đổi sang người kia
            showFloatingText("HẾT GIỜ!", player.x, player.y - 60, '#ff3d00'); 
            switchTurn();
        }
        // --- MENU CONFIG ---
        // Biến lưu chỉ số xe đã chọn của từng người
        let selectedTankIndexP1 = 0;
        let selectedTankIndexP2 = 0; // Mặc định xe khác P1 cho vui
        let selectedMapIndex = 0;

        // Hàm cập nhật hiển thị thông tin xe trên menu
        function updateMenuPreviews() {
            // Cập nhật P1
            const t1 = TANK_ROSTER[selectedTankIndexP1];
            document.getElementById('p1-tank-name').innerText = t1.name;
            document.getElementById('p1-tank-desc').innerText = t1.desc;

            // Cập nhật P2
            const t2 = TANK_ROSTER[selectedTankIndexP2];
            document.getElementById('p2-tank-name').innerText = t2.name;
            document.getElementById('p2-tank-desc').innerText = t2.desc;
            
            // Cập nhật Map
            const m = MAP_ROSTER[selectedMapIndex];
            document.getElementById('map-preview-name').innerText = m.name;
            document.getElementById('map-preview-desc').innerText = m.desc;
        }

        // Logic đổi xe cho Player 1
        function changeTankP1(dir) {
            selectedTankIndexP1 += dir;
            if (selectedTankIndexP1 < 0) selectedTankIndexP1 = TANK_ROSTER.length - 1;
            if (selectedTankIndexP1 >= TANK_ROSTER.length) selectedTankIndexP1 = 0;
            updateMenuPreviews();
        }

        // Logic đổi xe cho Player 2
        function changeTankP2(dir) {
            selectedTankIndexP2 += dir;
            if (selectedTankIndexP2 < 0) selectedTankIndexP2 = TANK_ROSTER.length - 1;
            if (selectedTankIndexP2 >= TANK_ROSTER.length) selectedTankIndexP2 = 0;
            updateMenuPreviews();
        }

        // Logic đổi Map (Giữ nguyên logic cũ, chỉ gọi updateMenuPreviews)
        function changeMap(dir) {
            selectedMapIndex += dir;
            if (selectedMapIndex < 0) selectedMapIndex = MAP_ROSTER.length - 1;
            if (selectedMapIndex >= MAP_ROSTER.length) selectedMapIndex = 0;
            updateMenuPreviews();
        }

        // Hàm chuyển đổi giữa các bước (Step)
        function goToStep(stepName) {
            document.getElementById('step-p1').style.display = 'none';
            document.getElementById('step-p2').style.display = 'none';
            document.getElementById('step-map').style.display = 'none';

            if (stepName === 'p1') {
                document.getElementById('step-p1').style.display = 'flex';
            } else if (stepName === 'p2') {
                document.getElementById('step-p2').style.display = 'flex';
            } else if (stepName === 'map') {
                document.getElementById('step-map').style.display = 'flex';
            }
        }
        // function startGame(mode) {
        //     selectedDifficulty = mode;
            
        //     // 1. Ẩn nút chọn độ khó
        //     document.getElementById('difficulty-buttons').style.display = 'none'; 
            
        //     // 2. Hiện menu Setup (Map + Tank)
        //     document.getElementById('setup-menu').style.display = 'flex'; 
            
        //     // 3. Đổi tiêu đề menu
        //     document.querySelector('.menu-title').innerText = "THIẾT LẬP TRẬN ĐẤU";
            
        //     // 4. [FIX QUAN TRỌNG] Cập nhật ngay tên và hình ảnh (để không hiện "TANK NAME")
        //     updateTankPreview(); // Cập nhật tên Tank
        //     updateMapPreview();  // Cập nhật tên Map
        // }

        // --- LOGIC MENU MỚI ---

        // 1. Hàm chọn độ khó -> Chuyển sang bước 2
        // function selectDifficultyAndNext(mode) {
        //     selectedDifficulty = mode;
            
        //     // Ẩn Bước 1 (Độ khó)
        //     document.getElementById('step-difficulty').style.display = 'none';
            
        //     // Hiện Bước 2 (Setup)
        //     document.getElementById('step-setup').style.display = 'flex';
            
        //     // [QUAN TRỌNG] Cập nhật thông tin Map/Tank ngay lập tức để không bị hiện chữ mặc định
        //     updateTankPreview(); 
        //     updateMapPreview();
        // }

        // 2. Hàm quay lại bước 1
        function backToDifficulty() {
            document.getElementById('step-setup').style.display = 'none';
            document.getElementById('step-difficulty').style.display = 'flex';
        }

        // 3. Giữ nguyên các hàm changeMap, changeTank cũ...

        // --- SỬA HÀM START GAME ---
        function confirmStartGame() {
            SoundManager.init(); 
            
            document.getElementById('start-menu').classList.add('hidden'); 
            gameState = 'INTRO';

            // 1. KHỞI TẠO MAP
            const MapClass = MAP_ROSTER[selectedMapIndex].className;
            currentMap = new MapClass(); 

            MAP_WIDTH = currentMap.width;
            MAP_HEIGHT = currentMap.height;
            GROUND_Y = currentMap.groundY;
            GRAVITY = currentMap.gravity;
            
            let startX_P1 = currentMap.pSpawnX;
            let startX_P2 = currentMap.aiSpawnX;

            // 2. KHỞI TẠO PLAYER 1 (Dựa trên selectedTankIndexP1)
            const ClassP1 = TANK_ROSTER[selectedTankIndexP1].className;
            const ColorP1 = TANK_ROSTER[selectedTankIndexP1].color;
            player = new ClassP1(startX_P1, ColorP1, 'Player 1', false);
            
            // 3. KHỞI TẠO PLAYER 2 (Dựa trên selectedTankIndexP2)
            const ClassP2 = TANK_ROSTER[selectedTankIndexP2].className;
            const ColorP2 = TANK_ROSTER[selectedTankIndexP2].color;
            player2 = new ClassP2(startX_P2, ColorP2, 'Player 2', false);

            // Cấu hình riêng cho P2 (Quay đầu, không phải AI)
            player2.angle = 135; 
            player2.scale = -1;  

            // 4. SETUP CHUNG
            player.y = -200; player.isParachuting = true;
            player2.y = -200; player2.isParachuting = true;
            
            skill4Uses = 2; 
            supplyDrops = [];
            
            // PvP thì không có chế độ Dễ/Khó, set mặc định
            currentModeName = 'PvP'; 
            turnDuration = 20;

            turn = 'PLAYER1';
            elChatHistory.innerHTML = ''; 
            elChatHistory.style.display = 'none';
            
            updateUI();
            updateSkillButtons(player); // Cập nhật nút cho P1 trước
        }
        
        // Gọi hàm này 1 lần khi load trang để hiện tên tank mặc định
        updateMenuPreviews();

        function init() {
            resizeCanvas();
            randomWind();
            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            const containerW = container.clientWidth; const containerH = container.clientHeight;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = Math.floor(containerW * dpr); canvas.height = Math.floor(containerH * dpr);
            canvas.style.width = containerW + 'px'; canvas.style.height = containerH + 'px';
            if (window.innerWidth < 600) { GAME_SCALE = 0.75; } else { GAME_SCALE = 1.0; }
            VIEWPORT_W = containerW / GAME_SCALE; SCREEN_H = containerH / GAME_SCALE;
            clampCamera();
        }

        window.addEventListener('resize', resizeCanvas);
        function clampCamera() {
            if (cameraX < 0) cameraX = 0;
            if (cameraX > MAP_WIDTH - VIEWPORT_W) cameraX = MAP_WIDTH - VIEWPORT_W;
            if (cameraY < 0) cameraY = 0;
            if (cameraY > MAP_HEIGHT - SCREEN_H) cameraY = MAP_HEIGHT - SCREEN_H;
            if (MAP_WIDTH < VIEWPORT_W) cameraX = -(VIEWPORT_W - MAP_WIDTH) / 2;
            if (MAP_HEIGHT < SCREEN_H) cameraY = -(SCREEN_H - MAP_HEIGHT) / 2;
            if (gameState === 'INTRO') { if (cameraY < -300) cameraY = -300; }
        }
        function randomWind() { wind = parseFloat(((Math.random() * 10) - 5).toFixed(1)); }

        // [SỬA] Thêm tham số 'caller' vào hàm
        function spawnSupplyDrop(caller) {
            let offset = (100 + Math.random() * 100) * (Math.random() < 0.5 ? 1 : -1);
            
            // [FIX QUAN TRỌNG] 
            // Dùng toạ độ của 'caller' (người gọi) thay vì luôn dùng 'player.x'
            // Nếu không có caller (ví dụ hệ thống tự thả) thì mặc định lấy player
            let originX = caller ? caller.x : player.x;
            
            let dropX = originX + offset; 
            
            // Giới hạn trong map
            dropX = Math.max(currentMap.minX + 50, Math.min(currentMap.maxX - 50, dropX));

            const newDrop = new SupplyDrop(dropX);
            supplyDrops.push(newDrop); 
            activeSupplyDrop = newDrop;
            
            // Hiện chat cho đúng người
            let name = (caller === player2) ? "P2" : "P1";
            addChatLog(name, "Đã gọi chi viện!");
        }

        function switchTurn() {
            if (gameState === 'ENDED') { stopTimer(); SoundManager.stopBGM(); return; }

            // Kiểm tra ai vừa bắn xong
            let justShot = turn.includes('PLAYER1') ? player : player2;
            let nextTurn = '';

            justShot.onTurnEnd();

            // Logic kiểm tra thêm lượt (Extra Shot item)
            if (justShot.extraShot) {
                justShot.extraShot = false;
                // Giữ nguyên lượt người đó
                nextTurn = turn.includes('PLAYER1') ? 'PLAYER1' : 'PLAYER2';
                
                showFloatingText("LƯỢT BẮN THÊM!", justShot.x, justShot.y - 80, '#2979ff');
            } else {
                // Đảo lượt
                if (turn.includes('PLAYER1')) {
                    nextTurn = 'PLAYER2';
                } else {
                    nextTurn = 'PLAYER1';
                }
            }

            // Kiểm tra thắng thua
            if (player.hp <= 0) endGame('PLAYER 2 THẮNG', '#1e88e5');
            else if (player2.hp <= 0) endGame('PLAYER 1 THẮNG', player.color);
            else {
                // Thiết lập lượt mới
                turn = nextTurn;
                let activeTank = (turn === 'PLAYER1') ? player : player2;
                
                activeTank.onTurnStart();
                updateSkillButtons(activeTank); // Cập nhật tên skill trên nút bấm

                // Reset các trạng thái chung
                charging = false; 
                currentPower = 0; 
                keys = {}; 
                SoundManager.stopCharge();
                randomWind(); 
                startTimer();

                // Di chuyển Camera tới người chơi hiện tại
                let targetX = activeTank.x - VIEWPORT_W / 2;
                // Đảm bảo camera không giật cục
                let steps = 0;
                let camInterval = setInterval(() => {
                    cameraX += (targetX - cameraX) * 0.1;
                    clampCamera();
                    steps++;
                    if(steps > 20) clearInterval(camInterval);
                }, 16);
            }
            
            updateUI();
        }

        function aiMovePhase() {
            if (isPaused) { setTimeout(aiMovePhase, 500); return; } 
            
            if (Math.random() > 0.8) { aiLogic(); return; }
            
            let dir = Math.random() < 0.6 ? -1 : 1; 
            let steps = Math.floor(Math.random() * 30) + 10; 
            let count = 0;

            let moveInterval = setInterval(() => {
                if (isPaused) return; 
                
                let nextX = ai.x + (dir * 2);
                
                // [FIX QUAN TRỌNG CHO AI]
                // Xác định vùng an toàn: Nếu map có cầu (bridgeStart) thì dùng giới hạn cầu
                // Nếu không có (map đảo dừa) thì dùng giới hạn map (minX)
                let safeMin = (currentMap.bridgeStart !== undefined) ? currentMap.bridgeStart : currentMap.minX;
                let safeMax = (currentMap.bridgeEnd !== undefined) ? currentMap.bridgeEnd : currentMap.maxX;

                // Thêm lề an toàn 20px để AI không đứng quá sát mép vực
                if (nextX > safeMin + 20 && nextX < safeMax - 20) { 
                    ai.move(dir); 
                }
                else { 
                    // Chạm giới hạn an toàn -> Dừng ngay và bắn
                    clearInterval(moveInterval); 
                    aiLogic(); 
                    return; 
                }
                
                count++; 
                if (count >= steps) { 
                    clearInterval(moveInterval); 
                    setTimeout(aiLogic, 500); 
                }
            }, 50);
        }

        function endGame(msg, color) { gameState = 'ENDED'; stopTimer(); elEndMsg.innerText = msg; elEndMsg.style.color = color; elEndScreen.classList.remove('hidden'); SoundManager.stopBGM(); }
        
        function createExplosion(x, y, count, type) {
            if (type === 'fire') { particles.push(new Particle(x, y, 'shockwave')); }
            for (let i = 0; i < count; i++) {
                let pType = (Math.random() < 0.3) ? 'smoke' : type; let speed = (Math.random() * 4) + 2;
                particles.push(new Particle(x, y, pType, { vx: (Math.random() - 0.5) * speed, vy: (Math.random() - 0.5) * speed, life: 1.0 + Math.random() * 0.5, decay: 0.03 + Math.random() * 0.02, size: Math.random() * 8 + 2 }));
            }
            if (type === 'fire') { for (let i = 0; i < 10; i++) { particles.push(new Particle(x, y, 'spark', { vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10 - 2, life: 0.8, size: 2 })); } }
        }

       function checkCollision() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                let hit = false;
                
                // Xác định người bắn để tính damage bonus (nếu có)
                let shooter = (turn.includes('PLAYER1')) ? player : player2;
                
                let potentialTargets = [player, player2]; 

                if (!b.isSpawner) { 
                     for (let target of potentialTargets) {
                        // Bỏ qua nếu mục tiêu đã chết
                        if (target.hp <= 0 || target.isDead) continue; 
                        
                        // [FIX LỖI QUAN TRỌNG TẠI ĐÂY]
                        // Dùng Math.abs(target.scale) để kích thước luôn dương
                        // Dù Player 2 có scale là -1 thì vùng va chạm vẫn là 25px
                        let hitDistX = 25 * Math.abs(target.scale); 
                        let hitDistY = 30 * Math.abs(target.scale);
                        
                        // Kiểm tra va chạm
                        if (Math.abs(b.x - target.x) < hitDistX && Math.abs(b.y - target.y) < hitDistY) {
                            hit = true;
                            
                            // Ghi nhận nếu Player 1 bắn trúng Player 2 (để hiện chat)
                            if (target === player2 && shooter === player) playerLandedHit = true;
                            
                            // Gây sát thương
                            b.handleCollision(target, shooter);
                            
                            // Kiểm tra kết thúc game
                            if (target.hp <= 0 && gameState !== 'ENDED' && !target.isDead) {
                                target.onDeath();
                                stopTimer(); 
                                setTimeout(() => {
                                    if (gameState !== 'ENDED') {
                                        if (target === player) endGame('PLAYER 2 THẮNG', player2.color); 
                                        else endGame('PLAYER 1 THẮNG', player.color); 
                                    }
                                }, 1500); 
                            }
                            break; // Đã trúng người này thì không check người kia nữa
                        }
                    }
                }
                
                // ... (Phần code bên dưới giữ nguyên)
                if (hit) {
                    bullets.splice(i, 1);
                    continue; 
                }

                // Check trúng hòm tiếp tế
                for (let j = supplyDrops.length - 1; j >= 0; j--) {
                    let s = supplyDrops[j];
                    
                    // [ĐÃ SỬA] Thêm "!s.isFalling" vào đầu điều kiện
                    // Ý nghĩa: Nếu thính KHÔNG CÒN RƠI (đã chạm đất) VÀ đạn bay trúng -> Thì mới nổ
                    if (!s.isFalling && Math.abs(b.x - s.x) < 25 && Math.abs(b.y - s.y) < 25) {
                        hit = true; 
                        createExplosion(s.x, s.y, 20, 'fire'); 
                        showFloatingText("HÀNG BỊ HỦY!", s.x, s.y - 40, '#ff3d00'); 
                        supplyDrops.splice(j, 1);
                        break;
                    }
                }
                if (hit) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Check trúng đất
                if (currentMap.isGroundCollision(b.x, b.y + 5)) {
                    hit = true;
                    let craterSize = b.isNuke ? 140 : (b instanceof MachineGunBullet ? 25 : 65);
                    currentMap.destroyGround(b.x, b.y, craterSize);
                    
                    b.onHit(null); 
                    SoundManager.playExplosion();
                    bullets.splice(i, 1);
                    continue; 
                }

                if (b.isDead) { 
                    bullets.splice(i, 1); 
                }
            }
        }

        function showFloatingText(txt, x, y, c, isChat = false) { floatingTexts.push({ text: txt, x: x, y: y, color: c, life: isChat ? 400 : 150, maxLife: isChat ? 400 : 150, isChat: isChat }); }
        function addChatLog(name, text, isSpecial = false) {
            elChatHistory.style.display = 'flex'; const div = document.createElement('div'); div.className = 'chat-item';
            let nameHtml = `<span class="chat-name">${name}:</span>`; let contentHtml = isSpecial ? `<span class="chat-system ${text === 'SKILL HỦY DIỆT!' ? '' : 'chat-finish'}">${text}</span>` : text;
            div.innerHTML = nameHtml + contentHtml; elChatHistory.appendChild(div); if (elChatHistory.children.length > 4) { elChatHistory.removeChild(elChatHistory.firstChild); }
        }

        const TAUNTS = {
            'DỄ': ["Bé yêu đỡ lấy!", "Nhẹ thôi nhé!", "Trúng nè hihi!", "Đừng khóc nha!", "Ahihi đồ ngốc!", "Cẩn thận vỡ đầu!", "Đau tí thôi à.", "Chạy đi đâu con sâu?", "Gà quá đi à!", "Nhìn anh biểu diễn nè."],
            'KHÓ': ["Mày Xong Rồi!", "Chạy đi đâu?", "Ăn đạn đi cưng!", "Non lắm!", "Về vườn đi em!", "Tuổi gì solo?", "Ngắm gà hóa cuốc à?", "Một vé về làng!", "Khóc to lên!", "Đỡ hộ cái!"],
            'BẤT LỰC': ["Sao mà đỡ được!", "Tuyệt vọng chưa?", "Về tập thêm đi!", "Game là dễ!", "Chấp 2 tay luôn!", "Hủy diệt thế giới!", "Biết bố là ai không?", "Niệm thần chú đi!", "Sợ chưa con trai?", "Cảm giác bất lực chưa?"],
            'MISS': ["Bắn chim hả?", "Mù à cưng?", "Gà thế!", "Lêu lêu bắn hụt!", "Ngắm bằng chân à?", "Còn non lắm!", "Về tập thêm đi!", "Sợ run tay à?", "Chả trúng tí nào!", "Ha ha quê chưa?"],
            'FINISH': ["An nghỉ nhé!", "Vĩnh biệt!", "Quá yếu đuối!", "Game over baby!", "Về thành dưỡng sức đi!", "Một phát lên bảng!", "Hẹn kiếp sau nhé!", "Kết thúc!", "Bye bye cưng!", "EZ Game!"]
        };
        function getSmartTaunt(category) {
            if (!chatPools[category] || chatPools[category].length === 0) { chatPools[category] = [...TAUNTS[category]]; }
            let randIndex = Math.floor(Math.random() * chatPools[category].length); return chatPools[category].splice(randIndex, 1)[0];
        }
        function aiLogic() {
            if (gameState === 'ENDED' || isPaused) { if (isPaused) setTimeout(aiLogic, 500); return; }
            let power = 100; let target = player; let aimMessage = "";
            let cratesOnGround = supplyDrops.filter(s => !s.isFalling);
            if (cratesOnGround.length > 0) {
                let targetCrate = cratesOnGround[0]; let testAngle = calculateFiringAngle(ai, targetCrate, power);
                if (testAngle !== null) { target = targetCrate; aimMessage = "Không ăn thì để tao phá!"; }
            }

            let perfectAngle = calculateFiringAngle(ai, target, power);
            let accuracyThreshold = Math.random() * (aiAccuracyMax - aiAccuracyMin) + aiAccuracyMin; 
            let isHit = Math.random() < accuracyThreshold;
            let finalAngle;

            if (perfectAngle !== null) {
                if (isHit) { finalAngle = perfectAngle; let tauntMsg = aimMessage !== "" ? aimMessage : getSmartTaunt(currentModeName); showFloatingText(tauntMsg, ai.x, ai.y - 90, '#000', true); addChatLog("Máy", tauntMsg); } 
                else { let deviation = (Math.random() * 2 + 1) * (Math.random() < 0.5 ? 1 : -1); finalAngle = perfectAngle + deviation; }
            } else { finalAngle = 180 - (Math.random() * 30 + 20); }

            ai.angle = finalAngle; turn = 'AI_SHOOTING';
            let newBullets = [];
            if (currentModeName === 'BẤT LỰC' && ai.hp < (ai.maxHp * 0.5) && Math.random() < 0.5 && target === player) {
                const skillMsg = "SKILL HỦY DIỆT!"; showFloatingText(skillMsg, ai.x, ai.y - 120, '#d500f9', true); addChatLog("Hệ thống", skillMsg, true);
                newBullets = ai.fireSkill1(power, wind);
            } else { newBullets = ai.fireNormal(power, wind); }
            bullets.push(...newBullets);
        }
        function calculateFiringAngle(shooter, target, power) {
            let validAngles = []; // Danh sách các góc bắn trúng
            let bestAngleFallback = null;
            let minDistance = 9999;

            // Quét từ 10 độ đến 89 độ
            for (let a = 10; a <= 89; a += 1.0) { // Tăng bước nhảy lên 1.0 cho nhanh
                let testAngle = 180 - a; // Máy bên phải bắn sang trái
                if (!shooter.isAI) testAngle = a; // Nếu test cho player
                
                let hit = simulateTrajectory(shooter, target, testAngle, power);
                
                if (hit.success) {
                    // [FIX]: Thay vì return ngay, ta lưu góc này lại
                    validAngles.push(testAngle);
                }

                // Lưu lại góc gần đúng nhất để dự phòng
                if (hit.distance < minDistance) { 
                    minDistance = hit.distance; 
                    bestAngleFallback = testAngle; 
                }
            } 

            // [LOGIC CHỌN GÓC THÔNG MINH]
            if (validAngles.length > 0) {
                // Nếu có nhiều góc bắn trúng (ví dụ: góc thấp 20 độ và góc cao 75 độ)
                // Chọn ngẫu nhiên một góc trong số đó.
                // Điều này làm cho AI đôi khi bắn thẳng, đôi khi bắn cầu vồng rất khó chịu.
                return validAngles[Math.floor(Math.random() * validAngles.length)];
            }

            return bestAngleFallback;
        }
        function simulateTrajectory(shooter, target, testAngle, p) {
            let bodyAngle = shooter.bodyAngle || 0;
            const rad = (testAngle * Math.PI / 180) - bodyAngle;

            // Tính vị trí đầu nòng
            const pivotX = 0 * Math.cos(bodyAngle) - (-10) * Math.sin(bodyAngle);
            const pivotY = 0 * Math.sin(bodyAngle) + (-10) * Math.cos(bodyAngle);
            const barrelLen = 44;
            const mx = Math.cos(rad) * barrelLen;
            const my = -Math.sin(rad) * barrelLen;

            let sx = shooter.x + pivotX + mx;
            let sy = shooter.y + pivotY + my;

            let phys = shooter.getPhysics(); 
            let speed = p * SPEED_CONSTANT * phys.powerMulti;
            let gravity = phys.gravity;
            
            let vx = Math.cos(rad) * speed;
            let vy = -Math.sin(rad) * speed;
            let minD = 9999;

            for (let i = 0; i < 1000; i++) {
                vx += wind * WIND_FACTOR; 
                vy += gravity;            
                sx += vx; 
                sy += vy;
                
                // Khoảng cách tới tim mục tiêu
                let dx = sx - target.x; 
                let dy = sy - target.y; 
                let d = Math.sqrt(dx * dx + dy * dy);
                
                // Nếu trúng HITBOX (30px) -> Thành công
                if (d < 30) return { success: true, distance: 0 };

                // [FIX QUAN TRỌNG NHẤT]: LOGIC VÙNG AN TOÀN
                // Nếu đạn đang bay ngang qua đầu hoặc ngay sát mục tiêu (trong khoảng 40px chiều ngang)
                // -> BỎ QUA kiểm tra va chạm đất. 
                // Điều này giúp AI tính toán được đường đạn xuyên qua chân cầu để trúng tim xe.
                let nearTarget = Math.abs(sx - target.x) < 40;

                if (!nearTarget) {
                    // Chỉ check va chạm đất khi còn ở xa mục tiêu (tránh bắn xuyên núi)
                    if (currentMap.isGroundCollision(sx, sy)) break;
                }

                if (d < minD) minD = d; 
                
                // Giới hạn rơi: Nếu rớt quá sâu so với mục tiêu thì dừng (để tránh lặp vô tận)
                if (sy > target.y + 100) break;
            } 
            
            return { success: false, distance: minD };
        }

        function drawAimGuide() {
            // 1. Chỉ vẽ khi game đang chơi (PLAYING)
            if (gameState !== 'PLAYING') return;

            // 2. Chỉ vẽ khi ĐÚNG LƯỢT NGƯỜI CHƠI (P1 hoặc P2)
            // Nếu đang là trạng thái SHOOTING (đạn đang bay), dòng này sẽ chặn lại -> Ẩn đường kẻ
            if (turn !== 'PLAYER1' && turn !== 'PLAYER2') return;

            // 3. Xác định xe tăng nào đang hoạt động
            let activeTank = (turn === 'PLAYER1') ? player : player2;
            
            // Nếu không tìm thấy xe hoặc xe đã chết thì thôi
            if (!activeTank || activeTank.hp <= 0) return;

            const settings = activeTank.getAimSettings(activeSkill);
            const drawSteps = settings.steps;

            // Dùng lực mặc định là 100 để vẽ đường hướng dẫn dài, 
            // hoặc dùng currentPower nếu bạn muốn nó ngắn dài theo lúc bấm nút
            let simPower = 100; 
            
            // Tính toán quỹ đạo
            let trajectory = activeTank.calculateTrajectory(simPower, wind, drawSteps);
            let points = trajectory.points;

            if (points.length < 2) return;

            ctx.save();
            
            // 4. [QUAN TRỌNG] Dời gốc tọa độ về đúng xe đang bắn (P1 hoặc P2)
            ctx.translate(activeTank.x, activeTank.y);

            if (settings.isSolid) {
                // Vẽ nét liền (Skill đặc biệt)
                let grad = ctx.createLinearGradient(points[0].x, points[0].y, points[points.length-1].x, points[points.length-1].y);
                grad.addColorStop(0, settings.colorStart); 
                grad.addColorStop(1, settings.colorEnd);
                ctx.strokeStyle = grad;
                ctx.setLineDash([]); 
            } else {
                // Vẽ nét đứt (Bắn thường)
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.setLineDash([5, 5]); // Tạo nét đứt: 5px vẽ, 5px nghỉ
            }

            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
            ctx.restore();
        }

        function gameLoop() {
            if (gameState !== 'ENDED' && !isPaused) {
                // Logic Intro (Thả dù)
                if (gameState === 'INTRO') {
                    let pLanded = player.updateParachute(); 
                    let aLanded = player2.updateParachute();
                    
                    let targetCamX = player.x - VIEWPORT_W / 2; 
                    let targetCamY = player.y - SCREEN_H / 2;
                    cameraX += (targetCamX - cameraX) * 0.1; 
                    cameraY += (targetCamY - cameraY) * 0.1; 
                    clampCamera();
                    
                    if (pLanded && aLanded) { 
                        gameState = 'PLAYING'; 
                        SoundManager.stopWind(); 
                        
                        // [ĐÃ SỬA] Kiểm tra đúng tên lượt là 'PLAYER1'
                        if (turn === 'PLAYER1') { 
                            startTimer(); // Hàm này sẽ set lại timeLeft = 20s
                            showFloatingText("BẮT ĐẦU!", player.x, player.y - 80, '#00e676'); 
                        }
                    }
                } 
                // Logic Playing (Trong trận)
                else if (gameState === 'PLAYING') {
                    
                    // --- [MỚI] CẬP NHẬT VẬT LÝ XE (RƠI, NGHIÊNG) ---
                    if (player) player.update();
                    if(player2) player2.update();
                    // ----------------------------------------------

                    if (activeSupplyDrop) {
                        let targetCamX = activeSupplyDrop.x - VIEWPORT_W / 2; 
                        let targetCamY = activeSupplyDrop.y - SCREEN_H / 2; 
                        cameraX += (targetCamX - cameraX) * 0.1; 
                        cameraY += (targetCamY - cameraY) * 0.1; 
                        clampCamera();
                    } else {
                        if (bullets.length > 0) {
                            bullets.forEach(b => b.update()); 
                            checkCollision();
                        }
                        
                        let activeBullets = bullets.filter(b => b.shouldCameraTrack);

                        if (activeBullets.length > 0) { 
                            let b = activeBullets[0]; 
                            let targetCamX = b.x - VIEWPORT_W / 2; 
                            let targetCamY = b.y - SCREEN_H / 2; 
                            cameraX += (targetCamX - cameraX) * 0.1; 
                            cameraY += (targetCamY - cameraY) * 0.1; 
                            clampCamera(); 
                        }else if (turn.includes('SHOOTING') && particles.length === 0) {
                            switchTurn(); 
                            
                            // [ĐÃ SỬA] Logic camera mới cho chế độ PvP
                            // Sau khi switchTurn(), biến 'turn' đã là người chơi tiếp theo.
                            // Chúng ta di chuyển camera tới người đó.
                            let targetX;
                            if (turn.includes('PLAYER1')) {
                                targetX = player.x - 200;
                            } else {
                                // Nếu là lượt Player 2
                                targetX = player2.x - (VIEWPORT_W - 200);
                            }

                            let targetY = MAP_HEIGHT - SCREEN_H; 
                            cameraX += (targetX - cameraX) * 0.05; 
                            cameraY += (targetY - cameraY) * 0.05; 
                            clampCamera();
                        }
                    }
                    supplyDrops.forEach((s, i) => { 
                        s.update(); 
                        if (s.intercepted && !s.isFalling) supplyDrops.splice(i, 1); 
                    });
                    
                    // Logic điều khiển
                    // Logic điều khiển
                    let activeTank = null;
                    if (turn === 'PLAYER1') activeTank = player;
                    if (turn === 'PLAYER2') activeTank = player2;

                    if (activeTank && !activeSupplyDrop) {
                        if (keys['ArrowLeft']) activeTank.move(-1); 
                        if (keys['ArrowRight']) activeTank.move(1); 
                        if (keys['ArrowUp']) activeTank.adjustAngle(1); 
                        if (keys['ArrowDown']) activeTank.adjustAngle(-1);
                        
                        if (charging) { 
                            SoundManager.startCharge(); 
                            SoundManager.updateCharge(currentPower); 
                            currentPower = Math.min(100, currentPower + 1.5); 
                            elPowerBar.style.width = currentPower + '%'; 
                        } else { 
                            SoundManager.stopCharge(); 
                        }
                        updateUI();
                    }
                }
                
                // Cập nhật Particle & Text
                particles.forEach((p, i) => { p.update(); if (p.life <= 0) particles.splice(i, 1); });
                floatingTexts.forEach((f, i) => { f.y -= f.isChat ? 0.05 : 0.5; f.life--; if (f.life <= 0) floatingTexts.splice(i, 1); });
            }
            
            // --- PHẦN VẼ (RENDERING) ---
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            ctx.save(); 
            ctx.scale(dpr * GAME_SCALE, dpr * GAME_SCALE);
            
            currentMap.drawBackground(ctx, VIEWPORT_W, SCREEN_H);
            
            ctx.save(); 
            ctx.translate(-cameraX, -cameraY); 
            
            drawAimGuide(); 
            currentMap.drawForeground(ctx, cameraX, VIEWPORT_W);

            supplyDrops.forEach(s => s.draw());
            
            if(player) player.draw(ctx);
            
           // [FIX] Vẽ khiên cho cả Player 1 và Player 2
            [player, player2].forEach(tank => {
                if (tank && tank.isShielded) { 
                    ctx.save(); 
                    ctx.strokeStyle = '#00ffff'; 
                    ctx.lineWidth = 3; 
                    ctx.shadowBlur = 10; 
                    ctx.shadowColor = '#00ffff'; 
                    
                    ctx.beginPath(); 
                    // Vẽ vòng tròn quanh xe
                    ctx.arc(tank.x, tank.y - 20, 35, 0, Math.PI * 2); 
                    ctx.stroke(); 
                    
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.2)'; 
                    ctx.fill(); 
                    ctx.restore(); 
                }
            });
            
            if(player2) player2.draw(ctx);
            
            bullets.forEach(b => b.draw(ctx)); 
            particles.forEach(p => p.draw());
            
            floatingTexts.forEach(ft => { 
                ctx.save(); let alpha = 1; if (ft.life < 30) alpha = ft.life / 30; ctx.globalAlpha = alpha; 
                if (ft.isChat) {
                    ctx.font = 'bold 13px Tahoma'; let textWidth = ctx.measureText(ft.text).width; let padding = 10; let boxW = textWidth + padding * 2; let boxH = 30; let boxX = ft.x - boxW / 2; let boxY = ft.y - 20;
                    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.moveTo(ft.x, boxY + boxH); ctx.lineTo(ft.x - 5, boxY + boxH + 6); ctx.lineTo(ft.x + 5, boxY + boxH + 6); ctx.fill();
                    ctx.fillStyle = 'white'; ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(boxX + 5, boxY); ctx.lineTo(boxX + boxW - 5, boxY); ctx.quadraticCurveTo(boxX + boxW, boxY, boxX + boxW, boxY + 5); ctx.lineTo(boxX + boxW, boxY + boxH - 5); ctx.quadraticCurveTo(boxX + boxW, boxY + boxH, boxX + boxW - 5, boxY + boxH); ctx.lineTo(boxX + 5, boxY + boxH); ctx.quadraticCurveTo(boxX, boxY + boxH, boxX, boxY + boxH - 5); ctx.lineTo(boxX, boxY + 5); ctx.quadraticCurveTo(boxX, boxY, boxX + 5, boxY); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = ft.color === '#d500f9' ? '#d500f9' : '#000'; ctx.fillText(ft.text, boxX + padding, boxY + 19);
                } else { 
                    ctx.font = 'bold 18px Arial'; ctx.lineWidth = 3; ctx.strokeStyle = 'black'; ctx.strokeText(ft.text, ft.x, ft.y); ctx.fillStyle = ft.color; ctx.fillText(ft.text, ft.x, ft.y); 
                }
                ctx.restore();
            });
            ctx.restore(); ctx.restore(); 
            
            drawMinimap(); 
            requestAnimationFrame(gameLoop);
        }
        function updateSkillButtons(tank) {
            // Tìm trong danh sách tank xem tank hiện tại thuộc loại nào (so sánh constructor class)
            let rosterItem = TANK_ROSTER.find(t => t.className === tank.constructor);
            
            if (rosterItem) {
                btnSkill1.querySelector('.skill-info').innerText = rosterItem.skill1Name;
                btnSkill2.querySelector('.skill-info').innerText = rosterItem.skill2Name;
            }
        }
        function updateUI() {
            // 1. Xác định ai đang chơi để hiển thị thông số của người đó
            let activeTank = (turn.includes('PLAYER2')) ? player2 : player;
            if (!activeTank) activeTank = player; // Fallback

            // Cập nhật thông số cơ bản
            elWind.innerText = (wind > 0 ? '→ ' : '← ') + Math.abs(wind); 
            elAngle.innerText = Math.floor(activeTank.angle) + '°'; 
            elHp.innerText = Math.max(0, activeTank.hp); 
            elMoveBar.style.width = (activeTank.moveEnergy / MAX_MOVE_ENERGY * 100) + '%';
            
            elModeText.innerText = "PvP"; 
            
            if (turn.includes('PLAYER1')) {
                elTurnText.innerText = 'P1 TURN'; elTurnText.style.color = player.color;
            } else if (turn.includes('PLAYER2')) {
                elTurnText.innerText = 'P2 TURN'; elTurnText.style.color = player2.color;
            } else {
                elTurnText.innerText = 'WAIT';
            }

            if ((turn === 'PLAYER1' || turn === 'PLAYER2') && gameState === 'PLAYING') { 
                elTimerText.innerText = timeLeft + 's'; 
                if (timeLeft <= 5) elTimerText.classList.add('timer-warning'); else elTimerText.classList.remove('timer-warning'); 
            } else { 
                elTimerText.innerText = '--'; elTimerText.classList.remove('timer-warning'); 
            }
            
            if (!charging) elPowerBar.style.width = currentPower + '%';
            
            const controlsArea = document.querySelector('.controls-area'); 
            const actionContainer = document.querySelector('.action-container');
            
            if ((turn === 'PLAYER1' || turn === 'PLAYER2') && gameState === 'PLAYING') { 
                controlsArea.style.opacity = '1'; controlsArea.style.pointerEvents = 'auto'; 
                actionContainer.style.opacity = '1'; actionContainer.style.pointerEvents = 'auto'; 
            } else { 
                controlsArea.style.opacity = '0.5'; controlsArea.style.pointerEvents = 'none'; 
                actionContainer.style.opacity = '0.5'; actionContainer.style.pointerEvents = 'none'; 
            }
            
            // [QUAN TRỌNG] LOGIC MỞ KHÓA SKILL DỰA TRÊN ACTIVE TANK
            // Skill 1 (< 80% HP)
            if (activeTank.skill1Used) { 
                btnSkill1.classList.remove('unlocked', 'active'); btnSkill1.classList.add('used'); 
            } else if (activeTank.hp < activeTank.maxHp * 0.8) { 
                btnSkill1.classList.add('unlocked'); btnSkill1.classList.remove('used');
            } else { 
                btnSkill1.classList.remove('unlocked', 'active', 'used'); 
                if (activeSkill === 1) activeSkill = null; 
            }
            
            // Skill 2 (< 60% HP)
            if (activeTank.skill2Used) { 
                btnSkill2.classList.remove('unlocked', 'active'); btnSkill2.classList.add('used'); 
            } else if (activeTank.hp < activeTank.maxHp * 0.6) { 
                btnSkill2.classList.add('unlocked'); btnSkill2.classList.remove('used');
            } else { 
                btnSkill2.classList.remove('unlocked', 'active', 'used'); 
                if (activeSkill === 2) activeSkill = null; 
            }
            
            // Skill 3 (< 40% HP - Khiên)
            if (activeTank.skill3Used) { 
                btnSkill3.classList.remove('unlocked', 'active'); btnSkill3.classList.add('used'); 
            } else if (activeTank.hp < activeTank.maxHp * 0.4) { 
                btnSkill3.classList.add('unlocked'); btnSkill3.classList.remove('used');
            } else { 
                btnSkill3.classList.remove('unlocked', 'active', 'used'); 
                if (activeSkill === 3) activeSkill = null; 
            }
            
            // Skill 4 (< 50% HP - Tiếp tế)
            if (activeTank.skill4Uses <= 0) { 
                btnSkill4.classList.remove('unlocked', 'active'); btnSkill4.classList.add('used'); 
                btnSkill4.querySelector('.skill-info').innerText = "Hết lượt"; 
            } else if (activeTank.hp < activeTank.maxHp * 0.5) { 
                btnSkill4.classList.add('unlocked'); btnSkill4.classList.remove('used'); 
                btnSkill4.querySelector('.skill-info').innerText = `Tiếp Tế (${activeTank.skill4Uses})`; 
            } else { 
                btnSkill4.classList.remove('unlocked', 'active', 'used'); 
                if (activeSkill === 4) activeSkill = null; 
            }
            
            updateFireButtonVisuals();
        }
        function updateFireButtonVisuals() { if (activeSkill) { btnFire.classList.add('skill-active-mode'); btnFire.innerText = "CHIÊU!"; } else { btnFire.classList.remove('skill-active-mode'); btnFire.innerText = "BẮN"; } }

        canvas.addEventListener('mousedown', e => { if (isPaused) return; isDragging = true; startDragX = e.clientX; startDragY = e.clientY; initialCameraX = cameraX; initialCameraY = cameraY; canvas.style.cursor = 'grabbing'; });
        window.addEventListener('mousemove', e => { if (!isDragging) return; cameraX = initialCameraX - (e.clientX - startDragX) / GAME_SCALE; cameraY = initialCameraY - (e.clientY - startDragY) / GAME_SCALE; clampCamera(); });
        window.addEventListener('mouseup', () => { isDragging = false; canvas.style.cursor = 'grab'; });
        canvas.addEventListener('touchstart', e => { if (isPaused) return; isDragging = true; startDragX = e.touches[0].clientX; startDragY = e.touches[0].clientY; initialCameraX = cameraX; initialCameraY = cameraY; }, { passive: false });
        window.addEventListener('touchmove', e => { if (!isDragging) return; cameraX = initialCameraX - (e.touches[0].clientX - startDragX) / GAME_SCALE; cameraY = initialCameraY - (e.touches[0].clientY - startDragY) / GAME_SCALE; clampCamera(); }, { passive: false });
        window.addEventListener('touchend', () => isDragging = false);

        function handleStart(act) {
            if (isPaused || activeSupplyDrop) return; 
            
            // Cho phép input nếu là lượt P1 hoặc P2 (đang không trong trạng thái bắn đạn bay)
            if ((turn === 'PLAYER1' || turn === 'PLAYER2') && gameState === 'PLAYING') {
                if (act !== 'fire') { keys[act] = true; } 
                else { charging = true; currentPower = 0; }
            }
        }
        function handleEnd(act) {
            if (isPaused || activeSupplyDrop) return; 
            
            if ((turn !== 'PLAYER1' && turn !== 'PLAYER2') || gameState !== 'PLAYING') { 
                charging = false; 
                return; 
            }

            if (act !== 'fire') { 
                keys[act] = false; 
            }
            else {
                charging = false; 
                SoundManager.stopCharge();

                if (currentPower > 5) {
                    if (typeof elLastPowerMarker !== 'undefined' && elLastPowerMarker) {
                        elLastPowerMarker.style.display = 'block';
                        elLastPowerMarker.style.left = currentPower + '%';
                    }

                    stopTimer(); 
                    
                    // Xác định tank đang bắn
                    let activeTank = (turn === 'PLAYER1') ? player : player2;
                    
                    turn = (turn === 'PLAYER1') ? 'PLAYER1_SHOOTING' : 'PLAYER2_SHOOTING';

                    let newBullets = [];
                    
                    // [QUAN TRỌNG] GỌI HÀM TỪ ACTIVE TANK VÀ CẬP NHẬT TRẠNG THÁI SKILL CỦA NÓ
                    if (activeSkill === 1) { 
                        newBullets = activeTank.fireSkill1(currentPower, wind); 
                        activeTank.skill1Used = true; // Đánh dấu đã dùng
                    }
                    else if (activeSkill === 2) { 
                        newBullets = activeTank.fireSkill2(currentPower, wind); 
                        activeTank.skill2Used = true; 
                    }
                    else if (activeSkill === 3) { 
                        // Skill 3 thường là buff khiên, không bắn đạn, nhưng nếu code cũ bắn đạn thường:
                        newBullets = activeTank.fireNormal(currentPower, wind); 
                        activeTank.skill3Used = true; 
                    }
                    else { 
                        newBullets = activeTank.fireNormal(currentPower, wind); 
                    }

                    bullets.push(...newBullets);
                    
                    activeSkill = null; 
                    [btnSkill1, btnSkill2, btnSkill3, btnSkill4].forEach(b => b.classList.remove('active'));
                    updateUI();
                } else { 
                    currentPower = 0; 
                    updateUI(); 
                }
            }
        }
        function toggleSkill(skillNum, btnElement) {
            if (isPaused || activeSupplyDrop) return; 
            if ((turn !== 'PLAYER1' && turn !== 'PLAYER2') || gameState !== 'PLAYING') return;
            
            // Xác định người chơi hiện tại
            let activeTank = (turn === 'PLAYER1') ? player : player2;
            
            if (!btnElement.classList.contains('unlocked') || btnElement.classList.contains('used')) return;
            
            // --- [XÓA DÒNG NÀY ĐI] ---
            // activeTank.isShielded = false;  <-- XÓA DÒNG NÀY (Dòng reset khiên vô lý)
            // -------------------------

            // Xử lý Skill 4 (Tiếp tế - Gọi ngay lập tức)
            if (skillNum === 4) { 
                spawnSupplyDrop(activeTank); 
                activeTank.skill4Uses--; 
                showFloatingText("GỌI TIẾP TẾ!", activeTank.x, activeTank.y - 80, '#fff'); 
                
                // [QUAN TRỌNG] Gọi thính xong thì không thay đổi activeSkill hiện tại
                // để tránh làm mất trạng thái chọn đạn nếu đang chọn
                updateUI(); 
                return; 
            }

            // Xử lý bật/tắt chọn skill (Skill 1, 2, 3)
            if (activeSkill === skillNum) { 
                // Nếu bấm lại vào skill đang chọn -> Tắt skill đó
                activeSkill = null; 
                btnElement.classList.remove('active'); 
                
                // Riêng xe Laser nếu tắt skill 2 thì thu hồi vệ tinh
                if (skillNum === 2 && activeTank instanceof LaserTank) { 
                    for (let i = bullets.length - 1; i >= 0; i--) { 
                        if (bullets[i].type === 'SATELLITE') bullets.splice(i, 1); 
                    }
                }
            } else { 
                // Chọn skill mới
                activeSkill = skillNum; 
                [btnSkill1, btnSkill2, btnSkill3, btnSkill4].forEach(b => b.classList.remove('active'));
                btnElement.classList.add('active'); 
                
                // Skill 3 (Khiên): Kích hoạt ngay lập tức và trừ lượt dùng (đánh dấu là used)
                if (activeSkill === 3) { 
                    activeTank.activateShield(); 
                    activeTank.skill3Used = true; // Đánh dấu đã dùng ngay lập tức
                    activeSkill = null; // Reset nút bấm để không bị kẹt ở trạng thái "đang chọn skill"
                    
                    // Cập nhật lại UI để nút skill bị mờ đi (thành used)
                    updateUI();
                    return; // Kết thúc hàm luôn, không cần làm gì thêm
                }
                
                if (activeSkill === 2 && activeTank instanceof LaserTank) { 
                    activeTank.deploySatellite(); 
                    showFloatingText("VỆ TINH SẴN SÀNG!", activeTank.x, activeTank.y - 80, '#d500f9'); 
                }
            }
            updateUI();
        }

        btnSkill1.addEventListener('click', (e) => { e.stopPropagation(); toggleSkill(1, btnSkill1); });
        btnSkill2.addEventListener('click', (e) => { e.stopPropagation(); toggleSkill(2, btnSkill2); });
        btnSkill3.addEventListener('click', (e) => { e.stopPropagation(); toggleSkill(3, btnSkill3); });
        btnSkill4.addEventListener('click', (e) => { e.stopPropagation(); toggleSkill(4, btnSkill4); });
        btnSkill1.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); toggleSkill(1, btnSkill1); });
        btnSkill2.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); toggleSkill(2, btnSkill2); });
        btnSkill3.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); toggleSkill(3, btnSkill3); });
        btnSkill4.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); toggleSkill(4, btnSkill4); });

        const mapBtn = { 'btn-left': 'ArrowLeft', 'btn-right': 'ArrowRight', 'btn-up': 'ArrowUp', 'btn-down': 'ArrowDown', 'btn-fire': 'fire' };
        Object.keys(mapBtn).forEach(id => {
            const el = document.getElementById(id); const action = mapBtn[id];
            const startAction = (e) => { if (e.cancelable) e.preventDefault(); e.stopPropagation(); handleStart(action); };
            const endAction = (e) => { if (e.cancelable) e.preventDefault(); e.stopPropagation(); handleEnd(action); };
            el.addEventListener('mousedown', startAction); el.addEventListener('touchstart', startAction, { passive: false });
            el.addEventListener('mouseup', endAction); el.addEventListener('touchend', endAction);
            el.addEventListener('mouseleave', (e) => { if (turn === 'PLAYER' && action === 'fire') { charging = false; currentPower = 0; SoundManager.stopCharge(); updateUI(); } else { endAction(e); } });
            el.addEventListener('touchcancel', endAction);
        });

        window.addEventListener('mouseup', () => { if (turn === 'PLAYER') { keys['ArrowLeft'] = false; keys['ArrowRight'] = false; keys['ArrowUp'] = false; keys['ArrowDown'] = false; } });
        window.addEventListener('contextmenu', e => e.preventDefault());
        init();
    </script>
</body>
</html>
